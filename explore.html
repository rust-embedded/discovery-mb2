<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What&#x27;s left for you to explore - Rust Embedded MB2 Discovery Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Discover the world of microcontrollers through Rust with the BB2 micro:bit v2">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Embedded MB2 Discovery Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/discovery-mb2/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="whats-left-for-you-to-explore"><a class="header" href="#whats-left-for-you-to-explore">What's left for you to explore</a></h1>
<p>We have barely scratched the surface! There's lots of stuff left for you to
explore.</p>
<blockquote>
<p><strong>NOTE:</strong> If you're reading this, and you'd like to help add examples or
exercises to the Discovery book for any of the items below, or any other
relevant embedded topics, we'd love to have your help!</p>
<p>Please <a href="https://github.com/rust-embedded/discovery-mb2/issues/new">open an issue</a> if you would like to help, but need assistance or
mentoring for how to contribute this to the book, or open a Pull Request
adding the information!</p>
</blockquote>
<h2 id="more-of-the-mb2"><a class="header" href="#more-of-the-mb2">More of the MB2</a></h2>
<p>We touched most of the hardware on the MB2 in the course of this book. That said, there's still a
few MB2 topics left to explore.</p>
<h2 id="direct-memory-access-dma"><a class="header" href="#direct-memory-access-dma">Direct Memory Access (DMA).</a></h2>
<p>Some peripherals have DMA, a kind of <em>asynchronous</em> <code>memcpy</code> that allows the peripheral to move data
into or out of memory without the CPU being involved.</p>
<p>If you are working with a micro:bit v2 you have actually already used DMA: the HAL does this for you
with the UARTE and TWIM peripherals. A DMA peripheral can be used to perform bulk transfers of data:
either from RAM to RAM, from a peripheral like a UARTE, to RAM, or from RAM to a peripheral. You can
schedule a DMA transfer — for example "read 256 bytes from UARTE into this buffer" — and leave it
running in the background. You can check some register later to see if the transfer has completed,
or you can ask to receive an interrupt when the transfer completes. Thus, you can schedule the DMA
transfer and do other work while the transfer is ongoing.</p>
<p>The details of low-level DMA can be a bit tricky. We hope to add a chapter covering this topic in
the near future.</p>
<p>There are some abstraction for working with PWM in the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/pwm/index.html"><code>pwm</code> module</a> and you will
find implementations of these traits in <code>nrf52833-hal</code>.</p>
<h2 id="digital-inputs-and-outputs"><a class="header" href="#digital-inputs-and-outputs">Digital inputs and outputs</a></h2>
<p>We have used the microcontroller pins as digital outputs, to drive LEDs. When building our snake
game, we also caught a glimpse of how these pins can be configured as digital inputs. As digital
inputs, these pins can read the binary state of switches (on/off) or buttons (pressed/not pressed).</p>
<p>Digital inputs and outputs are abstracted within the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/digital/index.html"><code>digital</code> module</a> and
[<code>nrf52833-hal</code>] does have an implementation for them.</p>
<p>(<em>spoilers</em> reading the binary state of switches / buttons is not as straightforward as it sounds
;-) )</p>
<h2 id="analog-to-digital-converters-adc"><a class="header" href="#analog-to-digital-converters-adc">Analog-to-Digital Converters (ADC)</a></h2>
<p>There are a lot of digital sensors out there. You can use a protocol like I2C and SPI to read
them. But analog sensors also exist! These sensors just output a reading to the CPU of the voltage
they are sensing at an ADC input pin.</p>
<p>The ADC peripheral can thus be used to measure an "analog" voltage level — for example, <code>1.25</code> Volts
— as a "digital" number — for example, <code>24824</code> — that the processor can use in its calculations.</p>
<p>There were generic ADC traits in <code>embedded-hal</code>, but they were removed for <code>embedded-hal</code> 1.0: see
<a href="https://github.com/rust-embedded/embedded-hal/issues/377">issue #377</a>. The <code>nrf52833-hal</code> crate provides a nice interface to the specific ADC built into the
nRF52833.</p>
<h2 id="digital-to-analog-converters-dac"><a class="header" href="#digital-to-analog-converters-dac">Digital-to-Analog Converters (DAC)</a></h2>
<p>As you might expect a DAC is exactly the opposite of ADC. You can write some digital number into a
register to produce a specific voltage on some analog output pin. When this analog output pin is
connected to some appropriate electronics and the register is written to quickly with the right
values you can do things like produce sounds or music.</p>
<p>Neither the nRF52833 nor the MB2 board has a dedicated DAC. One typically gets a kind of DAC effect
by outputting PWM and using a bit of electronics on the output (RC filter) to "smooth" out the PWM
waveform.</p>
<h2 id="real-time-clock"><a class="header" href="#real-time-clock">Real Time Clock</a></h2>
<p>A Real-Time Clock peripheral keeps track of time under its own power, usually in "human format":
seconds, minutes, hours, days, months and years.  Some Real-Time Clocks even handle leap years and
Daylight Saving Time automatically.</p>
<p>Neither the nRF52833 nor the MB2 board contains a Real-Time Clock. The nRF52833 does contain
"Real-Time Counter" (RTC), a low-frequency ticking clock that is supported by <code>nrf52833-hal</code>.  This
counter can be dedicated to serve as a synthesized real-time clock. The key requirement, of course,
is to keep the RTC peripheral powered even when the MB2 is not in use. While the MB2 does not have
an on-board battery, the RTC should be able to run for a long time (possibly years) with a battery
plugged into the battery port on the MB2 (for example, the battery pack provided with the micro::bit
Go kit).</p>
<h2 id="other-communication-protocols"><a class="header" href="#other-communication-protocols">Other communication protocols</a></h2>
<ul>
<li>SPI: The "Serial Peripheral Interface" is a high-speed communications interface similar in some
ways to I2C. SPI is abstracted within the <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/spi/index.html"><code>embedded-hal</code> <code>spi</code> module</a> and implemented by
[<code>nrf52-hal</code>].</li>
<li>I2S: The "Inter-IC Sound" protocol is a variant of I2C customized for audio transmission.
I2S is currently not abstracted within <code>embedded-hal</code>, but is implemented by [<code>nrf52-hal</code>].</li>
<li>Ethernet: there does exist a small TCP/IP stack named <a href="https://github.com/smoltcp-rs/smoltcp"><code>smoltcp</code></a> which is implemented for some
chips. The MB2 does not have an Ethernet peripheral</li>
<li>USB: there is some experimental work on this, for example with the <a href="https://github.com/mvirkkunen/usb-device"><code>usb-device</code></a> crate. For
the MB2, the USB port is managed by the interface MCU rather than the host MCU, making
it difficult to do custom USB things.</li>
<li>Bluetooth: the <code>nrf-softdevice</code> wrapper provided by the <a href="https://embassy.dev">Embassy</a> MB2 runtime is probably the
easiest entry into MB2 Bluetooth. Embassy also sports the Rust-native <a href="https://crates.io/crates/trouble-host"><code>TrouBLE</code></a> BLE host crate.</li>
<li>CAN, SMBUS, IrDA, etc: All kinds of specialty interfaces exist in the world; Rust sometimes has
support for them. Please investigate the current situation for the interface you need</li>
</ul>
<p>Different applications use different communication protocols. User facing applications usually have
a USB connector because USB is a ubiquitous protocol in PCs and smartphones. Whereas inside cars
you'll find plenty of CAN buses. Some digital sensors use SPI, I2C or SMBUS.</p>
<p>If you happen to be interested in developing abstractions in the <code>embedded-hal</code> or implementations
of peripherals in general, don't be shy to open an issue in the HAL repositories. Alternatively you
could also join the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a> and get into contact with most of the people who
built the stuff from above.</p>
<h2 id="general-embedded-relevant-topics"><a class="header" href="#general-embedded-relevant-topics">General Embedded-Relevant Topics</a></h2>
<p>These topics cover items that are not specific to our device, or the hardware on it. Instead, they
discuss useful techniques that could be used on embedded systems.</p>
<p>Most of the hardware we will discuss here is not available on the MB2 — but much of it could easily
be added by connecting a cheap piece of hardware to the MB2 edge-card connector, either driving it
directly or using something like SPI or I2C to control it.</p>
<h3 id="multitasking"><a class="header" href="#multitasking">Multitasking</a></h3>
<p>Most of our programs executed a single task. How could we achieve multitasking in a system with no
OS, and thus no threads? There are two main approaches to multitasking: preemptive multitasking and
cooperative multitasking.</p>
<p>In preemptive multitasking a task that's currently being executed can, at any point in time, be
<em>preempted</em> (interrupted) by another task. On preemption, the first task will be suspended and the
processor will instead execute the second task. At some point the first task will be resumed.
Microcontrollers provide hardware support for preemption in the form of <em>interrupts</em>. We were
introduced to interrupts when we built our snake game in <a href="16-snake-game/index.html">chapter 16</a>.</p>
<p>In cooperative multitasking a task that's being executed will run until it reaches a <em>suspension
point</em>. When the processor reaches that suspension point it will stop executing the current task and
instead go and execute a different task. At some point the first task will be resumed. The main
difference between these two approaches to multitasking is that in cooperative multitasking <em>yields</em>
execution control at <em>known</em> suspension points instead of being forcefully preempted at any point of
its execution.</p>
<h3 id="gyroscopes"><a class="header" href="#gyroscopes">Gyroscopes</a></h3>
<p>As part of our Punch-o-meter exercise, we used the Accelerometer to measure changes in acceleration
in three dimensions. But there are other motion sensors such as gyroscopes, which allows us to
measure changes in "spin" in three dimensions.</p>
<p>This can be very useful when trying to build certain systems, such as a robot that wants to avoid
tipping over. Additionally, the data from a sensor like a gyroscope can also be combined with data
from accelerometer using a technique called Sensor Fusion (see below for more information).</p>
<h3 id="servo-and-stepper-motors"><a class="header" href="#servo-and-stepper-motors">Servo and Stepper Motors</a></h3>
<p>While some motors are used primarily just to spin in one direction or the other, for example driving
a remote control car forwards or backwards, it is sometimes useful to measure more precisely how a
motor rotates.</p>
<p>A microcontroller can be used to drive Servo or Stepper motors, which allow for more precise control
of how many turns are being made by the motor, or can even position the motor in one specific place,
for example if we wanted to move the arms of a clock to a particular direction.</p>
<h3 id="sensor-fusion"><a class="header" href="#sensor-fusion">Sensor fusion</a></h3>
<p>The micro:bit contains two motion sensors: an accelerometer and a magnetometer.  On their own these
measure (proper) acceleration and (the Earth's) magnetic field.  But these magnitudes can be "fused"
into something more useful: a "robust" measurement of the orientation of the board, with less
measurement error than that of any single sensor.</p>
<p>This idea of deriving more reliable data from different sources is known as sensor fusion.</p>
<hr />
<p>So where to next?</p>
<p>First and foremost, join us on the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a>. Lots of people who contribute or
work on embedded software hang out there, including, for example, the people who wrote the
<code>microbit</code> BSP, the <code>nrf52-hal</code> crate, the <code>embedded-hal</code> crates, etc. We are happy to help you get
started or move on with embedded programming in Rust!</p>
<p>There are many other options:</p>
<ul>
<li>You could check out the examples in the <a href="https://github.com/nrf-rs/microbit/"><code>microbit-v2</code></a> board support crate. All those examples
work for the micro:bit board you have.</li>
</ul>
<ul>
<li>If you are looking for a general overview of what is available in Rust Embedded right now check
out the <a href="https://github.com/rust-embedded/awesome-embedded-rust/">Awesome Rust Embedded</a> list.</li>
</ul>
<ul>
<li>You could check out <a href="https://embassy.dev">Embassy</a>. This is a modern efficient cooperative multitasking framework that
supports concurrent execution using Rust <code>async/await</code>.</li>
</ul>
<ul>
<li>You could check out Real-Time Interrupt-driven Concurrency <a href="https://rtic.rs">RTIC</a>. RTIC is a very efficient
preemptive multitasking framework that supports task prioritization and deadlock-free execution.</li>
</ul>
<ul>
<li>You could check out more abstractions of the <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> project and maybe even try and write
your own platform agnostic driver based on it.</li>
</ul>
<ul>
<li>You could try running Rust on a different development board. Popular boards such as the ESP-32,
Raspberry Pi, or Arduino have their own active Rust developer communities.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="16-snake-game/final-assembly.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="DOWNLOAD.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="16-snake-game/final-assembly.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="DOWNLOAD.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="epub-link.js"></script>


    </div>
    </body>
</html>
