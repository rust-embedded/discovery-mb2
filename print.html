<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Embedded MB2 Discovery Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Discover the world of microcontrollers through Rust with the BB2 micro:bit v2">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Embedded MB2 Discovery Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/discovery-mb2/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="microbit-v2-embedded-discovery-book"><a class="header" href="#microbit-v2-embedded-discovery-book"><code>micro::bit v2 Embedded Discovery Book</code></a></h1>
<blockquote>
<p>Discover the world of microcontrollers through <a href="https://www.rust-lang.org/">Rust</a>!</p>
</blockquote>
<p>This book is an introductory course on microcontroller-based embedded systems that uses Rust as the
teaching language rather than the usual C/C++.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The following topics will be covered (eventually, I hope):</p>
<ul>
<li>
<p>How to write, build, flash and debug an "embedded" (Rust) program.</p>
</li>
<li>
<p>Functionality ("peripherals") commonly found in microcontrollers: Digital input and output, Pulse
Width Modulation (PWM), Analog to Digital Converters (ADC), common communication protocols like
Serial, I2C and SPI, etc.</p>
</li>
<li>
<p>Multitasking concepts: cooperative vs preemptive multitasking, interrupts, schedulers, etc.</p>
</li>
<li>
<p>Control systems concepts: sensors, calibration, digital filters, actuators, open loop control,
closed loop control, etc.</p>
</li>
</ul>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<ul>
<li>
<p>Beginner friendly. No previous experience with microcontrollers or embedded systems is required.</p>
</li>
<li>
<p>Hands on. Plenty of exercises to put the theory into practice. <em>You</em> will be doing most of the
work here.</p>
</li>
<li>
<p>Tool centered. We'll make plenty use of tooling to ease development. "Real" debugging, with GDB,
and logging will be introduced early on. Using LEDs as a debugging mechanism has no place here.</p>
</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h2>
<p>What's out of scope for this book:</p>
<ul>
<li>
<p>Teaching Rust. There's plenty of material on that topic already. We'll focus on microcontrollers
and embedded systems.</p>
</li>
<li>
<p>Being a comprehensive text about electric circuit theory or electronics. We'll just cover the
minimum required to understand how some devices work.</p>
</li>
<li>
<p>Covering details such as linker scripts and the boot process. For example, we'll use existing tools
to help get your code onto your board, but not go into detail about how those tools work.</p>
</li>
</ul>
<p>Also I don't intend to port this material to other development boards; this book will make exclusive
use of the micro:bit development board.</p>
<h2 id="reporting-problems"><a class="header" href="#reporting-problems">Reporting problems</a></h2>
<p>The source of this book is in <a href="https://github.com/rust-embedded/discovery-mb2">this repository</a>. If you encounter any typo or problem with the code
report it on the <a href="https://github.com/rust-embedded/discovery-mb2/issues">issue tracker</a>.</p>
<h2 id="other-embedded-rust-resources"><a class="header" href="#other-embedded-rust-resources">Other embedded Rust resources</a></h2>
<p>This Discovery book is just one of several embedded Rust resources provided by the
<a href="https://github.com/rust-embedded/wg">Embedded Working Group</a>. The full selection can be found at <a href="https://docs.rust-embedded.org">The Embedded Rust Bookshelf</a>. This
includes the list of <a href="https://docs.rust-embedded.org/faq.html">Frequently Asked Questions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<p>You are about to write "bare-metal" Rust for a microcontroller. Maybe you have never done anything
like this before. That's <em>fantastic</em> — welcome to an awesome adventure!</p>
<p>We should start by answering some basic questions you might have.</p>
<ul>
<li>
<p><strong>What's a microcontroller?</strong></p>
<p>A microcontroller is a <em>system</em> on a chip. Whereas your computer is made up of several discrete
components: a processor, RAM, storage, an Ethernet port, etc.; a microcontroller has all those types
of components built into a single "chip" or package. This makes it possible to build systems with
fewer parts.</p>
</li>
<li>
<p><strong>What can you do with a microcontroller?</strong></p>
<p>Lots of things! Microcontrollers are the central part of what are known as "<em>embedded</em> systems".
Embedded systems are everywhere, but you don't usually notice them. They control the machines that
wash your clothes, print your documents, and cook your food. Embedded systems keep the buildings
that you live and work in at a comfortable temperature, and control the components that make the
vehicles you travel in stop and go.</p>
<p>Most embedded systems operate without user intervention. Even if they expose a user interface like a
washing machine does; most of their operation is done on their own.</p>
<p>Embedded systems are often used to <em>control</em> a physical process. To make this possible, they have
one or more devices to tell them about the state of the world ("sensors"), and one or more
devices which allow them to change things ("actuators"). For example, a building climate control
system might have:</p>
<ul>
<li>Sensors which measure temperature and humidity in various locations.</li>
<li>Actuators which control the speed of fans.</li>
<li>Actuators which cause heat to be added or removed from the building.</li>
</ul>
</li>
<li>
<p><strong>When should I use a microcontroller?</strong></p>
<p>Many of the embedded systems listed above could be implemented with a computer running Linux (for
example a "Raspberry Pi"). Why use a microcontroller instead? Sounds like it might be harder to
develop a program.</p>
<p>Some reasons might include:</p>
<ul>
<li>
<p><em>Cost:</em> A microcontroller is much cheaper than a general purpose computer. Not only is the
microcontroller cheaper; it also requires many fewer external electrical components to operate.
This makes Printed Circuit Boards (PCB) smaller and cheaper to design and manufacture.</p>
</li>
<li>
<p><em>Power consumption:</em> Most microcontrollers consume a fraction of the power of a full blown
processor. For applications which run on batteries, that makes a huge difference.</p>
</li>
<li>
<p><em>Responsiveness:</em> To accomplish their purpose, some embedded systems must always react within a
limited time interval (e.g. the "anti-lock" braking system of a car). If the system misses this
type of <em>deadline</em>, a catastrophic failure might occur. Such a deadline is called a "hard real
time" requirement. An embedded system which is bound by such a deadline is referred to as a "hard
real-time system". A general purpose computer and OS usually has many software components which
share the computer's processing resources. This makes it harder to guarantee execution of a
program within tight time constraints.</p>
</li>
<li>
<p><em>Reliability.</em> In systems with fewer components (both hardware and software), there is less to go
wrong!</p>
</li>
</ul>
</li>
<li>
<p><strong>When should I <em>not</em> use a microcontroller?</strong></p>
<p>Microcontrollers are often not great at heavy computational work. To keep their cost and power
consumption low, microcontrollers have limited computational resources available to them.</p>
<p>Microcontrollers can typically execute fewer instructions per second than "big" processors. The
slowest parts might run at "only" a few million instructions per second. In addition, the amount of
work per instruction is typically lower. Microcontroller parts are typically "32 bit", but "16 bit"
parts are not uncommon: this may mean more instructions to work with typical Rust datatypes. Most
microcontrollers have no or little "cache", meaning instructions can run only as fast as main memory
can be accessed.</p>
<p>Some microcontrollers don't have hardware support for floating point operations. On those
devices, performing a simple addition of single precision numbers can take hundreds of CPU cycles.</p>
<p>Finally, microcontrollers typically come with limited memory. Memory sizes may be as small as 16KB
for program instructions and 4KB for data, making programming for these systems quite challenging.
While the internal memory size per unit cost and power consumption is constantly increasing, the
processor we will work with still has "only" 512KB for program instructions and 256KB for data — far
less than that of a "real computer".</p>
</li>
<li>
<p><strong>Why use Rust and not C?</strong></p>
<p>Hopefully, I don't need to convince you here as you are probably familiar with the language
differences between Rust and C. One point I do want to bring up is package management. C lacks an
official, widely accepted package management solution whereas Rust has Cargo. This makes development
<em>much</em> easier. And, IMO, easy package management encourages code reuse because libraries can be
easily integrated into an application which is also a good thing as libraries get more "battle
testing".</p>
</li>
<li>
<p><strong>Why should I not use Rust?</strong></p>
<p>Or why should I prefer C over Rust?</p>
<p>The C ecosystem is more mature. Off-the-shelf solutions for several problems already exist. If you
need to control a time sensitive process, you can grab one of the existing commercial Real Time
Operating Systems (RTOS) out there and solve your problem. There are no commercial, production-grade
RTOSes in Rust (as of this writing) so you would have to either create one yourself or try one of
the ones that are in development. You can find a list of those in the <a href="https://github.com/rust-embedded/awesome-embedded-rust#real-time-operating-system-rtos">Awesome Embedded Rust</a>
repository.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardwareknowledge-requirements"><a class="header" href="#hardwareknowledge-requirements">Hardware/knowledge requirements</a></h1>
<p>The primary knowledge requirement to read this book is to know <em>some</em> Rust. It's hard for me to
quantify <em>some</em>. Being familiar with the basics of generics and traits is quite helpful. You do need
to know how to <em>use</em> closures. You also need to be familiar with the idioms of the current Rust
<a href="https://rust-lang-nursery.github.io/edition-guide/">edition</a>.</p>
<p>Also, to follow this material you'll need:</p>
<ul>
<li>
<p>A <a href="https://tech.microbit.org/hardware/">Micro:Bit v2</a> (MB2) board.</p>
<p>You can purchase this board from many suppliers, including
Amazon and Ali Baba. You can get a <a href="https://microbit.org/buy/">list</a> of suppliers
directly from the BBC, the manufacturers of MB2.</p>
<p align="center">
<img title="micro:bit" src="02-requirements/../assets/microbit-v2.jpg" width="500" />
</p>
<p>There are several versions of the <code>V2</code> board
available. While the material here was written for <code>V2.00</code>,
things should work fine with with any <code>V2</code> board.</p>
</li>
<li>
<p>A micro-B USB cable (nothing special — you probably have many of these). This is required
to power the micro:bit board when not on battery, and to communicate with it.  Make sure
that the cable supports data transfer, as some cables only support charging devices.</p>
<p align="center">
<img title="micro-B USB cable" src="02-requirements/../assets/usb-cable.jpg" width="500" />
</p>
<blockquote>
<p><strong>NOTE</strong> Some micro:bit kits ship with such cables.  USB cables used with other mobile
devices should work, if they are micro-B and have the capability to transmit data.</p>
</blockquote>
<p>The official <code>micro:bit Go</code> kit provides both the USB cable and a nifty battery pack for powering
the MB2 without USB.</p>
</li>
</ul>
<blockquote>
<p><strong>FAQ</strong>: Wait, why do I need this specific hardware?</p>
</blockquote>
<p>It makes my life and yours much easier.</p>
<p>The material is much, much more approachable if we don't have to worry about hardware differences.
Trust me on this one.</p>
<blockquote>
<p><strong>FAQ</strong>: Can I follow this material with a different development board?</p>
</blockquote>
<p>Maybe? It depends mainly on two things: your previous experience with microcontrollers and/or
whether a high level crate already exists for your development board somewhere. You probably want at
least a HAL crate, like <a href="https://docs.rs/nrf52833-hal"><code>nrf52833-hal</code></a> used here.  You may prefer a board with a Board Support crate,
like <a href="https://docs.rs/microbit-v2"><code>microbit-v2</code></a> used here.  If you intend to use a different microcontroller, you can look
through <a href="https://github.com/rust-embedded/awesome-embedded-rust">Awesome Embedded Rust</a> or just search the web to find supported crates.</p>
<p>With a different development board, this text loses most if not all its beginner friendliness and
"easy to follow"-ness, in my opinion: you have been warned.</p>
<p>If you have a different Arm-based development board and you don't consider yourself a total
beginner, you might consider starting with the <a href="https://rust-embedded.github.io/cortex-m-quickstart/cortex_m_quickstart/">quickstart</a> project template.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-development-environment"><a class="header" href="#setting-up-a-development-environment">Setting up a development environment</a></h1>
<p>Dealing with microcontrollers involves several tools as we'll be dealing with an architecture
different from your computer's and we'll have to run and debug programs on a "remote" device.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Tooling is not everything though. Without documentation, it is pretty much impossible to work with
microcontrollers. The official MB2 technical documentation is at <a href="https://tech.microbit.org">https://tech.microbit.org</a>. We
will reference other technical documentation throughout the book.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>We'll use all the tools listed below. Where a minimum version is not specified, any recent version
should work but we have listed the version we have tested.</p>
<ul>
<li>
<p>Rust 1.79.0 or a newer toolchain.</p>
</li>
<li>
<p><code>gdb-multiarch</code>. This is a debugging tool. The oldest tested version is 10.2, but other versions
will most likely work as well.  If your distribution/platform does not have <code>gdb-multiarch</code>
available <code>arm-none-eabi-gdb</code> will do the trick as well. Furthermore, some normal <code>gdb</code> binaries
are built with multiarch capabilities as well: you can find further information about this in the
debugging chapter of this book.</p>
</li>
<li>
<p><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a>. Version 0.3.6 or newer.</p>
</li>
<li>
<p><a href="https://probe.rs/docs/overview/about-probe-rs/"><code>probe-rs-tools</code></a>. Version 0.24.0 or newer.</p>
</li>
<li>
<p><code>minicom</code> on Linux and macOS. Tested version: 2.7.1. Other versions will most likely work as well
though.</p>
</li>
<li>
<p><code>PuTTY</code> on Windows.</p>
</li>
</ul>
<p>Next, follow OS-agnostic installation instructions for a few of the tools:</p>
<h3 id="rustc--cargo"><a class="header" href="#rustc--cargo"><code>rustc</code> &amp; Cargo</a></h3>
<p>Install rustup by following the instructions at <a href="https://rustup.rs">https://rustup.rs</a>.</p>
<p>If you already have rustup installed, double check that you are on the stable channel and your
stable toolchain is up-to-date. <code>rustc -V</code> should return a date and version no older than the one
shown below:</p>
<pre><code class="language-console">$ rustc -V
rustc 1.79.0 (129f3b996 2024-06-10)
</code></pre>
<h3 id="cargo-binutils"><a class="header" href="#cargo-binutils"><code>cargo-binutils</code></a></h3>
<pre><code class="language-console">$ rustup component add llvm-tools
$ cargo install cargo-binutils --vers '^0.3'
$ cargo size --version
cargo-size 0.3.6
</code></pre>
<h3 id="probe-rs-tools"><a class="header" href="#probe-rs-tools"><code>probe-rs-tools</code></a></h3>
<p><strong>NOTE</strong> If you already have old versions of <code>probe-run</code>, <code>probe-rs</code> or <code>cargo-embed</code> installed
on your system, remove them before starting this step, as they could conceivably cause problems
for you down the line. In particular, <code>probe-run</code> no longer officially exists. Try these as
needed:</p>
<pre><code class="language-console">$ cargo uninstall cargo-embed
$ cargo uninstall probe-run
$ cargo uninstall probe-rs
$ cargo uninstall probe-rs-cli
</code></pre>
<p>In order to install <code>probe-rs-tools</code>, go to <a href="https://probe.rs">https://probe.rs</a> and follow the current installation
instructions there.</p>
<ul>
<li>
<p><strong>NOTE</strong> If you prefer to install <code>probe-rs-tools</code> using <code>cargo install</code>, you can try the
following steps.  Folks have experienced frequent failures with this approach, but you are
welcome to give it a go.</p>
<ol>
<li>
<p>Upgrade to the most recent stable Rust.</p>
</li>
<li>
<p>Install the <code>probe-rs-tools</code> binary
<a href="https://probe.rs/docs/getting-started/installation/">prerequisites</a>.  (The linked
instructions are part of the more general <a href="https://probe.rs/"><code>probe-rs</code></a> embedded debugging
toolkit documentation.)</p>
</li>
<li>
<p>Try the install</p>
<pre><code class="language-console">$ cargo install --locked probe-rs-tools
</code></pre>
</li>
</ol>
</li>
</ul>
<p>Installing <code>probe-rs-tools</code> will install several useful tools, including <code>probe-rs</code> and
<code>cargo-embed</code> (which is normally run as a Cargo command). Check that things are working before
proceeding.</p>
<pre><code>$ cargo embed --version
cargo-embed 0.24.0 (git commit: crates.io)
</code></pre>
<h3 id="this-repository"><a class="header" href="#this-repository">This repository</a></h3>
<p>This book also contains some small Rust codebases used in various chapters: the easiest way to use
these is to download the book's source code. You can do this in one of the following ways:</p>
<ul>
<li>
<p>Visit the <a href="https://github.com/rust-embedded/discovery-mb2/">repository</a>, click the green "Code"
button and then the "Download Zip" one.</p>
</li>
<li>
<p>Clone it using <code>git</code> (if you know <code>git</code> you presumably already have it installed) from the same
repository as linked in the Zip approach.</p>
</li>
</ul>
<h3 id="os-specific-instructions"><a class="header" href="#os-specific-instructions">OS specific instructions</a></h3>
<p>Now follow the instructions specific to the OS you are using:</p>
<ul>
<li><a href="03-setup/linux.html">Linux</a></li>
<li><a href="03-setup/windows.html">Windows</a></li>
<li><a href="03-setup/macos.html">macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>Here are the installation commands for a few Linux distributions.</p>
<h2 id="ubuntu-2004-or-newer--debian-10-or-newer"><a class="header" href="#ubuntu-2004-or-newer--debian-10-or-newer">Ubuntu 20.04 or newer / Debian 10 or newer</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>gdb-multiarch</code> is the GDB command you'll use to debug your Arm Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo apt install gdb-multiarch minicom libunwind-dev
</code></pre>
<h2 id="fedora-32-or-newer"><a class="header" href="#fedora-32-or-newer">Fedora 32 or newer</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>gdb</code> is the GDB command you'll use to debug your Arm
Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo dnf install gdb minicom libunwind-devel
</code></pre>
<h2 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>gdb</code> is the GDB command you'll use to debug your Arm
Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo pacman -S arm-none-eabi-gdb minicom libunwind
</code></pre>
<h2 id="other-distros"><a class="header" href="#other-distros">Other distros</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your Arm Cortex-M programs.</p>
</blockquote>
<p>For distros that don't have packages for <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm's pre-built
toolchain</a>, download the "Linux
64-bit" file and put its <code>bin</code> directory on your path.  Here's one way to do it:</p>
<pre><code class="language-console">$ mkdir -p ~/local
$ cd ~/local
$ tar xjf /path/to/downloaded/XXX.tar.bz2
</code></pre>
<p>Then, use your editor of choice to append to your <code>PATH</code> in the appropriate shell init file
(e.g. <code>~/.zshrc</code> or <code>~/.bashrc</code>):</p>
<pre><code>PATH=$PATH:$HOME/local/XXX/bin
</code></pre>
<h2 id="udev-rules"><a class="header" href="#udev-rules">udev rules</a></h2>
<p>These rules let you use USB devices like the micro:bit without root privilege, i.e. <code>sudo</code>.</p>
<p>Create this file in <code>/etc/udev/rules.d</code> with the content shown below.</p>
<pre><code class="language-console">$ cat /etc/udev/rules.d/69-microbit.rules
</code></pre>
<pre><code class="language-text"># CMSIS-DAP for microbit
ACTION!="add|change", GOTO="microbit_rules_end"
SUBSYSTEM=="usb", ATTR{idVendor}=="0d28", ATTR{idProduct}=="0204", TAG+="uaccess"
LABEL="microbit_rules_end"
</code></pre>
<p>Then reload the udev rules with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload
</code></pre>
<p>If you had any board plugged to your computer, unplug them and then plug them in again, or run the
following command.</p>
<pre><code class="language-console">$ sudo udevadm trigger
</code></pre>
<h2 id="verify-permissions"><a class="header" href="#verify-permissions">Verify permissions</a></h2>
<p>Connect the micro:bit to your computer using a USB cable.</p>
<p>The micro:bit should now appear as a USB device (file) in <code>/dev/bus/usb</code>. Let's find out how it got
enumerated:</p>
<pre><code class="language-console">$ lsusb | grep -i "NXP Arm mbed"
Bus 001 Device 065: ID 0d28:0204 NXP Arm mbed
$ # ^^^        ^^^
</code></pre>
<p>In my case, the micro:bit got connected to the bus #1 and got enumerated as the device #65. This means the
file <code>/dev/bus/usb/001/065</code> <em>is</em> the micro:bit. Let's check the file permissions:</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/001/065
crw-rw-r--+ 1 nobody nobody 189, 64 Sep  5 14:27 /dev/bus/usb/001/065
</code></pre>
<p>The permissions should be <code>crw-rw-r--+</code>, note the <code>+</code> at the end, then see your access rights by running the following command.</p>
<pre><code class="language-console">$ getfacl /dev/bus/usb/001/065
getfacl: Removing leadin '/' from absolute path names
# file: dev/bus/usb/001/065
# owner: nobody
# group: nobody
user::rw-
user:&lt;YOUR-USER-NAME&gt;:rw-
group::rw-
mask::rw-
other::r-
</code></pre>
<p>You should see your username in the list above with the
<code>rw-</code> permissions, if not ... then check your <a href="03-setup/linux.html#udev-rules">udev rules</a>
and try re-loading them with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload
$ sudo udevadm trigger
</code></pre>
<p>Now, go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<h2 id="arm-none-eabi-gdb"><a class="header" href="#arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<p>Arm provides <code>.exe</code> installers for Windows. Grab one from <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">here</a>, and follow the instructions.
Just before the installation process finishes tick/select the "Add path to environment variable"
option. Then verify that the tools are in your <code>%PATH%</code>:</p>
<pre><code class="language-console">$ arm-none-eabi-gcc -v
(..)
gcc version 5.4.1 20160919 (release) (..)
</code></pre>
<h2 id="putty"><a class="header" href="#putty">PuTTY</a></h2>
<p>Download the latest <code>putty.exe</code> from <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">this site</a> and place it somewhere in your <code>%PATH%</code>.</p>
<p>Now, go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>All the tools can be installed using <a href="http://brew.sh/">Homebrew</a>:</p>
<pre><code class="language-console">$ # GDB debugger - The version in brew is built for all architectures including all of the ARM embedded cores
$ brew install gdb

$ # Minicom
$ brew install minicom

$ # lsusb lists USB ports
$ brew install lsusb
</code></pre>
<p>That's all! Go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verify-the-installation"><a class="header" href="#verify-the-installation">Verify the installation</a></h1>
<p>Let's verify that all the tools were installed correctly.</p>
<h2 id="verifying-cargo-embed"><a class="header" href="#verifying-cargo-embed">Verifying cargo-embed</a></h2>
<p>First, connect the micro:bit to your Computer using a USB cable.</p>
<p>At least an orange LED right next to the USB port of the micro:bit should light up.  Furthermore, if
you have never flashed another program on to your micro:bit, the default program the micro:bit ships
with should start blinking the red LEDs on its back: you can ignore them, or you can play with the
demo app.</p>
<p>Now let's see if probe-rs, and by extensions cargo-embed can see your micro:bit. You can do this by
running the following command:</p>
<pre><code class="language-console">$ probe-rs list
The following debug probes were found:
[0]: BBC micro:bit CMSIS-DAP -- 0d28:0204:990636020005282030f57fa14252d446000000006e052820 (CMSIS-DAP)
</code></pre>
<p>Or if you want more information about the micro:bits debug capabilities then you can run:</p>
<pre><code class="language-console">$ probe-rs info
Probing target via JTAG

Error identifying target using protocol JTAG: The probe does not support the JTAG protocol.

Probing target via SWD

Arm Chip with debug port Default:
Debug Port: DPv1, DP Designer: Arm Ltd
├── 0 MemoryAP
│   └── ROM Table (Class 1), Designer: Nordic VLSI ASA
│       ├── Cortex-M4 SCS   (Generic IP component)
│       │   └── CPUID
│       │       ├── IMPLEMENTER: Arm Ltd
│       │       ├── VARIANT: 0
│       │       ├── PARTNO: Cortex-M4
│       │       └── REVISION: 1
│       ├── Cortex-M3 DWT   (Generic IP component)
│       ├── Cortex-M3 FBP   (Generic IP component)
│       ├── Cortex-M3 ITM   (Generic IP component)
│       ├── Cortex-M4 TPIU  (Coresight Component)
│       └── Cortex-M4 ETM   (Coresight Component)
└── 1 Unknown AP (Designer: Nordic VLSI ASA, Class: Undefined, Type: 0x0, Variant: 0x0, Revision: 0x0)


Debugging RISC-V targets over SWD is not supported. For these targets, JTAG is the only supported protocol. RISC-V specific information cannot be printed.
Debugging Xtensa targets over SWD is not supported. For these targets, JTAG is the only supported protocol. Xtensa specific information cannot be printed.
</code></pre>
<p>Next, make sure you are in <code>src/03-setup</code> of this book's source code. Then run these commands:</p>
<pre><code>$ rustup target add thumbv7em-none-eabihf
$ cargo embed --target thumbv7em-none-eabihf
</code></pre>
<p>If everything works correctly cargo-embed should first compile the small example program
in this directory, then flash it and finally open a nice text based user interface that
prints Hello World.</p>
<p>(If it does not, check out <a href="03-setup/../appendix/1-general-troubleshooting/index.html">general troubleshooting</a> instructions.)</p>
<p>This output is coming from the small Rust program you just flashed on to your micro:bit.
Everything is working properly and you can continue with the next chapters!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-the-most-out-of-your-ide"><a class="header" href="#getting-the-most-out-of-your-ide">Getting the most out of your IDE</a></h1>
<p>All code in this book assumes that you use a simple terminal to build your code,
run it, and interact with it. It also makes no assumption about your text editor.</p>
<p>However, you may have your favourite IDEs, providing you auto-complete, type annotation,
your preferred shortcuts and much more. This section explains how to get the most out
of your IDE using the code obtained from this book's repo.</p>
<h1 id="ide-configuration"><a class="header" href="#ide-configuration">IDE configuration</a></h1>
<p>Below, we explain how to configure your IDE to get the most out of this book.
If your IDE is not listed below, please improve this book by adding a section, so that the next
reader can get the best experience out of it.</p>
<h2 id="how-to-build-with-intellij"><a class="header" href="#how-to-build-with-intellij">How to build with IntelliJ</a></h2>
<p>When editing the IntelliJ build configuration, here are a few non-default values:</p>
<ul>
<li>You should edit the command. When this book tells you to run <code>cargo embed FLAGS</code>,
You'll need to replace the default value <code>run</code> by the command <code>embed FLAGS</code>,</li>
<li>You should enable "Emulate terminal in output console". Otherwise, your program will fail to print text to a terminal</li>
<li>You should ensure that the working directory is <code>microbit/src/N-name</code>, with <code>N-name</code> being the directory of the chapter you
are reading. You can not run from the <code>src</code> directory since it contains no cargo file.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meet-your-hardware"><a class="header" href="#meet-your-hardware">Meet your hardware</a></h1>
<p>Let's get familiar with the hardware we'll be working with.</p>
<h2 id="microbit"><a class="header" href="#microbit">micro:bit</a></h2>
<p align="center">
<img title="micro:bit" src="04-meet-your-hardware/../assets/microbit-v2.jpg" />
</p>
<p>Here are some of the many components on the board:</p>
<ul>
<li>A <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>.</li>
<li>A number of LEDs, most notably the LED matrix on the back</li>
<li>Two user buttons as well as a reset button (the one next to the USB port).</li>
<li>One USB port.</li>
<li>A sensor that is both a <a href="https://en.wikipedia.org/wiki/Magnetometer">magnetometer</a> and an <a href="https://en.wikipedia.org/wiki/Accelerometer">accelerometer</a></li>
</ul>
<p>Of these components, the most important is the microcontroller (sometimes
shortened to "MCU" for "microcontroller unit"), which is the bigger of the two
black squares sitting on the side of the board with the USB port. The MCU is
what runs your code. You might sometimes read about "programming a board", when
in reality what we are doing is programming the MCU that is installed on the board.</p>
<p>If you happen to be interested in a more detailed description of the board you
can checkout the <a href="https://tech.microbit.org/hardware/">micro:bit website</a>.</p>
<p>Since the MCU is so important, let's take a closer look at the one sitting on our board.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nordic-nrf52833-the-nrf52-microbit-v2"><a class="header" href="#nordic-nrf52833-the-nrf52-microbit-v2">Nordic nRF52833 (the "nRF52", micro:bit v2)</a></h1>
<p>Our MCU has 73 tiny metal <strong>pins</strong> sitting right underneath it (it's a so called <a href="https://en.wikipedia.org/wiki/Flat_no-leads_package">aQFN73</a> chip).
These pins are connected to <strong>traces</strong>, the little "roads" that act as the wires connecting
components together on the board. The MCU can dynamically alter the electrical properties of the
pins. This works similarly to a light switch, altering how electrical current flows through a
circuit. By enabling or disabling electrical current to flow through a specific pin, an LED attached
to that pin (via the traces) can be turned on and off.</p>
<p>Each manufacturer uses a different part numbering scheme, but many will allow you to
determine information about a component simply by looking at the part number. Looking at our
MCU's part number we find <code>N52833 QIAAA0 2024AL</code>: you probably cannot see it with your bare
eye, but it is on the chip. (If you have a later revision of MB2, your number may vary
somewhat. This not an issue. The <code>N52833</code> part should be there, though.) The <code>N</code> at the
front hints to us that this is a part manufactured by <a href="https://www.nordicsemi.com/">Nordic Semiconductor</a>.  Looking up
the part number on their website we quickly find the <a href="https://www.nordicsemi.com/products/nrf52833">product page</a>.  There we learn that
our chip's main marketing point is that it is a "Bluetooth Low Energy and 2.4 GHz SoC" (SoC
being short for "System on a Chip"), which explains the RF in the product name since RF is
short for radio frequency.  If we search through the documentation of the chip linked on the
<a href="https://www.nordicsemi.com/products/nrf52833">product page</a> for a bit we find the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf">product specification</a> which contains chapter 10
"Ordering Information" dedicated to explaining the weird chip naming. Here we learn that:</p>
<ul>
<li>The <code>N52</code> is the MCU's series, indicating that there are other <code>nRF52</code> MCUs</li>
<li>The <code>833</code> is the part code</li>
<li>The <code>QI</code> is the package code, short for <code>aQFN73</code></li>
<li>The <code>AA</code> is the variant code, indicating how much RAM and flash memory the MCU has,
in our case 512 kilobyte flash and 128 kilobyte RAM</li>
<li>The <code>A0</code> is the build code, indicating the hardware version (<code>A</code>) as well as the product configuration (<code>0</code>)</li>
<li>The <code>2024AL</code> is a tracking code, hence it might differ on your chip</li>
</ul>
<p>The product specification does of course contain a lot more useful information about the chip: for
example, that the chip is an Arm® Cortex™-M4 32-bit processor.</p>
<h2 id="arm-cortex-m4"><a class="header" href="#arm-cortex-m4">Arm? Cortex-M4?</a></h2>
<p>If our chip is manufactured by Nordic, then who is Arm? And if our chip is the
nRF52833, what is the Cortex-M4?</p>
<p>You might be surprised to hear that while "Arm-based" chips are quite
popular, the company behind the "Arm" trademark (<a href="https://www.arm.com/">Arm Holdings</a>) doesn't
actually manufacture chips for purchase. Instead, their primary business
model is to just <em>design</em> parts of chips. They will then license those designs to
manufacturers, who will in turn implement the designs (perhaps with some of
their own tweaks) in the form of physical hardware that can then be sold.
Arm's strategy here is different from companies like Intel, which both
designs <em>and</em> manufactures their chips.</p>
<p>Arm licenses a bunch of different designs. Their "Cortex-M" family of designs
are mainly used as the core in microcontrollers. For example, the Cortex-M4
(the core our chip is based on) is designed for low cost and low power usage.
The Cortex-M7 is higher cost, but with more features and performance.</p>
<p>Luckily, you don't need to know too much about different types of processors
or Cortex designs for the sake of this book. However, you are hopefully now a
bit more knowledgeable about the terminology of your device. While you are
working specifically with an nRF52833, you might find yourself reading
documentation and using tools for Cortex-M-based chips, as the nRF52833 is
based on a Cortex-M design.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-embedded-terminology"><a class="header" href="#rust-embedded-terminology">Rust Embedded terminology</a></h1>
<p>Before we dive into programming the micro:bit let's have a quick look at the libraries and
terminology that will be important for all the future chapters.</p>
<h2 id="abstraction-layers"><a class="header" href="#abstraction-layers">Abstraction layers</a></h2>
<p>For any fully supported microcontroller/board with a microcontroller, you will usually hear the
following terms being used for their levels of abstraction:</p>
<h3 id="peripheral-access-crate-pac"><a class="header" href="#peripheral-access-crate-pac">Peripheral Access Crate (PAC)</a></h3>
<p>The job of the PAC is to provide a safe (ish) direct interface to the peripherals of the chip,
allowing you to configure every last bit however you want (of course also in wrong ways). Usually
you only ever have to deal with the PAC if either the layers that are higher up don't fulfill your
needs or when you are developing higher-level code for them.  Unsurprisingly, the PAC we are (mostly
implicitly) going to use is for the <a href="https://crates.io/crates/nrf52833-pac">nRF52</a>.</p>
<h3 id="hardware-abstraction-layer-hal"><a class="header" href="#hardware-abstraction-layer-hal">Hardware Abstraction Layer (HAL)</a></h3>
<p>The job of the HAL is to build up on top of the chip's PAC and provide an abstraction that is
actually usable for someone who does not know about all the special behaviour of this chip.  Usually
a HAL abstracts whole peripherals away into single structs that can, for example, be used to send
data around via the peripheral. We are going to use the <a href="https://crates.io/crates/nrf52833-hal">nRF52-hal</a>.</p>
<h3 id="board-support-crate-bsp"><a class="header" href="#board-support-crate-bsp">Board Support Crate (BSP)</a></h3>
<p>(In non-Rust situations this is usually called the Board Support Package, hence the acronym.)</p>
<p>The job of the BSP is to abstract a whole board (such as the micro:bit) away at once. That means it
has to provide abstractions to use both the microcontroller as well as the sensors, LEDs etc. that
might be present on the board. Quite often (especially with custom-made boards) no pre-built BSP
will be available. Instead you will be working with a HAL for the chip and build the drivers for the
sensors either yourself or search for them on <code>crates.io</code>. Luckily for us though, the micro:bit does
have a <a href="https://crates.io/crates/microbit-v2">BSP</a>, so we are going to use that on top of our HAL as well.</p>
<h2 id="unifying-the-layers"><a class="header" href="#unifying-the-layers">Unifying the layers</a></h2>
<p>Next we are going to have a look at a very central piece of software
in the Rust Embedded world: <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>. As its name suggests it
relates to the 2nd level of abstraction we got to know: the HALs.
The idea behind <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> is to provide a set of traits that
describe behaviour which is usually shared across all implementations
of a specific peripheral in all the HALs. For example one would always
expect to have functions that are capable of turning the power on a pin
either on or off: to switch an LED on and off on the board or whatever.</p>
<p><code>embedded-hal</code> allows us to write a driver for some piece of hardware, for example a temperature
sensor, that can be used on any chip for which an implementation of the <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> traits
exists. This is accomplished by writing the driver in such a way that it only relies on the
<a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> traits. Drivers that are written in such a way are called <em>platform-agnostic.</em>
Luckily for us, the drivers we will be getting from <code>crates.io</code> are almost all platform agnostic.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>If you want to learn more about these levels of abstraction, Franz Skarman (a.k.a. <a href="https://github.com/TheZoq2/">TheZoq2</a>) held a
talk about this topic during Oxidize 2020: <a href="https://www.youtube.com/watch?v=vLYit_HHPaY">An Overview of the Embedded Rust Ecosystem</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meet-your-software"><a class="header" href="#meet-your-software">Meet your software</a></h1>
<p>In this chapter we will learn how to build, run and debug some <em>very</em> simple programs. The goal here
is not to get into the details of MB2 Rust programming (yet), but to just familiarize yourself with
the mechanics of the process.</p>
<p>First, a quick note about the conventions used in the rest of this book. We expect you to get
a copy of the whole book with</p>
<pre><code>git clone http://github.com/rust-embedded/discovery-mb2
</code></pre>
<p>The book's "source code" is in <code>discovery-mb2/mdbook/src</code>. You should go there in your copy and look
around a bit. Each chapter directory has both the source Markdown text <em>and</em> the complete source for
all the programs in that chapter. When we refer to some path like <code>src/main.rs</code>, we mean that place
starting from the chapter you are working in. For example, your <code>discovery-mb2</code> has a file called
<code>mdbook/src/05-meet-your-software/examples/init.rs</code>. We will refer to that file as just
<code>examples/init.rs</code> in this chapter.</p>
<p>There are two basic kinds of Rust code: "binary" executable programs, and "library" code. The
library code won't play a huge role in this book. Binary program source code can live in one of
several places:</p>
<ul>
<li>
<p>A program in <code>src/main.rs</code> will be automatically compiled and run by <code>cargo embed</code> or <code>cargo run</code>. No special flags are needed.</p>
</li>
<li>
<p>A program in <code>examples/foo.rs</code> can be compiled and run by <code>cargo embed --example foo</code> or
<code>cargo run --example foo</code>.</p>
</li>
<li>
<p>A program in <code>src/bin/bar.rs</code> can be compiled and run by <code>cargo embed --bin bar</code> or
<code>cargo run --bin bar</code>.</p>
</li>
</ul>
<p>This is confusing, but it's a standard convention of Cargo.</p>
<p>Now let's move on and work with all this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-it"><a class="header" href="#build-it">Build it</a></h1>
<p>The first step is to build our "binary" crate. Because the microcontroller has a different
architecture than your computer we'll have to cross compile. Cross compiling in Rust land is as
simple as passing an extra <code>--target</code> flag to <code>rustc</code>or Cargo. The complicated part is figuring out
the argument of that flag: the <em>name</em> of the target.</p>
<p>As we already know the microcontroller on the micro:bit v2 has a Cortex-M4F processor in it.
<code>rustc</code> knows how to cross-compile to the Cortex-M architecture and provides several different
targets that cover the different processors families within that architecture:</p>
<ul>
<li><code>thumbv6m-none-eabi</code>, for the Cortex-M0 and Cortex-M1 processors</li>
<li><code>thumbv7m-none-eabi</code>, for the Cortex-M3 processor</li>
<li><code>thumbv7em-none-eabi</code>, for the Cortex-M4 and Cortex-M7 processors</li>
<li><code>thumbv7em-none-eabihf</code>, for the Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> processors</li>
<li><code>thumbv8m.main-none-eabi</code>, for the Cortex-M33 and Cortex-M35P processors</li>
<li><code>thumbv8m.main-none-eabihf</code>, for the Cortex-M33<strong>F</strong> and Cortex-M35P<strong>F</strong> processors</li>
</ul>
<p>"Thumb" here refers to a version of the Arm instruction set that has smaller instructions for
reduced code size (it's a pun, see). The <code>hf</code>/<code>F</code> parts have hardware floating point
acceleration. This will make numeric computations involving fractional ("floating decimal point")
computations much faster.</p>
<p>For the micro:bit v2, we'll want the <code>thumbv7em-none-eabihf</code> target.</p>
<p>Before cross-compiling you have to download a pre-compiled version of the standard library (a
reduced version of it, actually) for your target. That's done using <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<p>You only need to do the above step once; <code>rustup</code> will then update this target (re-installing a new
standard library <code>rust-std</code> component that contains the <code>core</code> library we use) whenever you update
your toolchain. Therefore you can skip this step if you have already added the necessary target
while <a href="05-meet-your-software/../03-setup/verify.html#verifying-cargo-embed">verifying your setup</a>.</p>
<p>With the <code>rust-std</code> component in place you can now cross compile the program using Cargo.  Make sure
you are in the <code>mdbook/src/05-meet-your-software</code> directory in the Git repo, then build. This initial code
is an example, so we compile it as such.</p>
<pre><code class="language-console">$ cargo build --example init
   Compiling semver-parser v0.7.0
   Compiling proc-macro2 v1.0.86
   ...

    Finished dev [unoptimized + debuginfo] target(s) in 33.67s
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Be sure to compile this crate <em>without</em> optimizations. The provided <code>Cargo.toml</code> file and
build command above will ensure optimizations are off as long as you <em>don't</em> pass <code>cargo</code> the
<code>--release</code> flag.</p>
</blockquote>
<p>OK, now we have produced an executable. This executable won't blink any LEDs: it's just a simplified
version that we will build upon later in the chapter.  As a sanity check, let's verify that the
produced executable is actually an Arm binary. (The command below is equivalent to</p>
<pre><code>readelf -h ../../../target/thumbv7em-none-eabihf/debug/examples/init
</code></pre>
<p>on systems that have <code>readelf</code>.)</p>
<pre><code class="language-console">$ cargo readobj --example init -- --file-headers
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Arm
  Version:                           0x1
  Entry point address:               0x117
  Start of program headers:          52 (bytes into file)
  Start of section headers:          793112 (bytes into file)
  Flags:                             0x5000400
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         21
  Section header string table index: 19
</code></pre>
<p>If your numbers don't exactly match these, don't worry: a lot of this is quite dependent
on the current build environment.</p>
<p>Next, we'll flash the program into our microcontroller.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flash-it"><a class="header" href="#flash-it">Flash it</a></h1>
<p>Flashing is the process of moving our program into the microcontroller's persistent memory. Once
flashed, the microcontroller will execute the flashed program every time it is powered on.</p>
<p>Our program will be the <em>only</em> program in the microcontroller memory.  By this I mean that there's
nothing else running on the microcontroller: no OS, no "daemon", nothing. Our program has full
control over the device.</p>
<p>Flashing the binary itself is quite simple, thanks to <code>cargo embed</code>.</p>
<p>Before executing that command though, let's look into what it actually does. If you look at the side
of your micro:bit with the USB connector facing upwards, you will notice that there are actually
three black squares on there. The biggest one is a speaker. Another is our MCU we already talked
about… but what purpose does the remaining one serve? This chip is <em>another</em> MCU, an NRF52820 almost
as powerful as the NRF52833 we will be programming! This chip has three main purposes:</p>
<ol>
<li>Enable power and reset control of our NRF52833 MCU from the USB connector.</li>
<li>Provide a serial to USB bridge for our MCU (we will look into that in a later chapter).</li>
<li>Provide an interface for programming and debugging our NRF52833 (this is the relevant purpose for
now).</li>
</ol>
<p>This chip acts as sort of bridge between our computer (to which it is connected via USB) and the MCU
(to which it is connected via traces and communicates with using the SWD protocol). This bridge
enables us to flash new binaries on to the MCU, inspect a program's state via a debugger and do
other useful things.</p>
<p>So lets flash it!</p>
<pre><code class="language-console">$ cargo embed --example init
  (...)
     Erasing sectors ✔ [00:00:00] [####################################################################################################################################################]  2.00KiB/ 2.00KiB @  4.21KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [####################################################################################################################################################]  2.00KiB/ 2.00KiB @  2.71KiB/s (eta 0s )
    Finished flashing in 0.608s
</code></pre>
<p>You will notice that <code>cargo-embed</code> does not exit after outputting the last line. This is intended:
you should not close <code>cargo-embed</code>, since we need it in this state for the next step — debugging it!
Furthermore, you will have noticed that <code>cargo build</code> and <code>cargo embed</code> are actually passed the same
flags. This is because <code>cargo embed</code> actually executes the build and then flashes the resulting
binary on to the chip. This means you can leave out the <code>cargo build</code> step in the future if you want
to flash your code right away.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-it"><a class="header" href="#debug-it">Debug it</a></h1>
<p>Let's figure out how to debug our little program. It doesn't really have any interesting bugs yet,
but that's the best kind of program to learn debugging on.</p>
<h2 id="how-does-this-even-work"><a class="header" href="#how-does-this-even-work">How does this even work?</a></h2>
<p>Before we debug our program let's take a moment to quickly understand what is actually happening
here. In the previous chapter we already discussed the purpose of the second chip on the board, as
well as how it talks to our computer, but how can we actually use it?</p>
<p>The little option <code>default.gdb.enabled = true</code> in <code>Embed.toml</code> made <code>cargo embed</code> open a so-called
"GDB stub" after flashing. This is a server that our GDB can connect to and send commands like "set
a breakpoint at address X". The server can then decide on its own how to handle this command. In the
case of the <code>cargo embed</code> GDB stub it will forward the command via USB to the "debugging probe" on
the second chip. This chip does the job of talking to the MCU for us.</p>
<h2 id="lets-debug"><a class="header" href="#lets-debug">Let's debug!</a></h2>
<p><code>cargo-embed</code> is running in our current shell. We can open a new shell and go back into our project
directory. Once we are there we first have to open the binary in gdb like this:</p>
<pre><code class="language-shell">$ gdb ../../../target/thumbv7em-none-eabihf/debug/examples/init
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Depending on which GDB you installed you will have to use a different command to launch
it. Check out <a href="05-meet-your-software/../03-setup/index.html#tools">chapter 3</a> if you forgot which one it was.</p>
</blockquote>
<p>The <code>../../..</code> in this command is needed, since each example project is in a "workspace" that
contains the entire book. Workspaces have a single shared <code>target</code> directory. Check out <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html#creating-a-workspace">Workspaces
chapter in Rust Book</a> for more.</p>
<blockquote>
<p><strong>NOTE</strong> If <code>cargo-embed</code> prints a lot of warnings here don't worry about it. As of now it does
not fully implement the GDB protocol, and thus might not recognize all the commands your GDB is
sending to it. As long as GDB does not crash, you are fine.</p>
</blockquote>
<p>Next we will have to connect to the GDB stub. It runs on <code>localhost:1337</code> by default so in order to
connect to it run the following:</p>
<pre><code class="language-shell">(gdb) target remote :1337
Remote debugging using :1337
0x00000116 in nrf52833_pac::{{impl}}::fmt (self=0xd472e165, f=0x3c195ff7) at /home/nix/.cargo/registry/src/github.com-1ecc6299db9ec823/nrf52833-pac-0.9.0/src/lib.rs:157
157     #[derive(Copy, Clone, Debug)]
</code></pre>
<blockquote>
<p><strong>NOTE</strong> The example in the repository for this chapter may change over time. Line numbers and
other source details may thus be different from what is shown here and below.</p>
<p>If the program fails to halt after starting, and you end up somewhere deeper in the program like
the following, then try running <code>monitor reset halt</code> to reset. This is due to <a href="https://github.com/probe-rs/probe-rs/issues/3438">a bug</a>
in <code>probe-rs</code>, see <a href="https://github.com/rust-embedded/discovery-mb2/issues/27">issue #27</a> for
more details.</p>
<pre><code class="language-shell">(gdb) target remote :1337
Remote debugging using :1337
init::__cortex_m_rt_main () at mdbook/src/05-meet-your-software/examples/init.rs:19
19              asm::nop();
(gdb) monitor reset halt
Resetting and halting target
Target halted
</code></pre>
</blockquote>
<p>Next what we want to do is get to the <code>main</code> function of our program.  We will do this by first
setting a breakpoint there and then continuing program execution until we hit the breakpoint:</p>
<pre><code>(gdb) break main
Breakpoint 1 at 0x104: file src/05-meet-your-software/examples/init.rs, line 9.
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) continue
Continuing.

Breakpoint 1, init::__cortex_m_rt_main_trampoline () at src/05-meet-your-software/examples/init.rs:9
9       #[entry]
</code></pre>
<p>Breakpoints can be used to stop the normal flow of a program. The <code>continue</code> command will let the
program run freely <em>until</em> it reaches a breakpoint. In this case, until it reaches the <code>main</code>
function because there's a breakpoint there.</p>
<p>Note that GDB output says "Breakpoint 1". Remember that our processor can only use a limited amount
of these breakpoints, so it's a good idea to pay attention to these messages. If you happen to run
out of breakpoints, you can list all the current ones with <code>info break</code> and delete desired ones with
<code>delete &lt;breakpoint-num&gt;</code>.</p>
<p>For a nicer debugging experience, we'll be using GDB's Text User Interface (TUI). To enter into that
mode, on the GDB shell enter the following command:</p>
<pre><code>(gdb) layout src
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Apologies Windows users. The GDB shipped with the GNU Arm Embedded Toolchain doesn't
support this TUI mode <code>:-(</code>.</p>
</blockquote>
<p><img src="05-meet-your-software/../assets/gdb-layout-src.png" alt="GDB session" title="GDB TUI" /></p>
<p>GDB's break command does works for more than just function names: it can also break at certain line
numbers.  If we want to break in line 13 we can simply do:</p>
<pre><code>(gdb) break 13
Breakpoint 2 at 0x110: file src/05-meet-your-software/examples/init.rs, line 13.
(gdb) continue
Continuing.

Breakpoint 2, init::__cortex_m_rt_main () at src/05-meet-your-software/examples/init.rs:13
(gdb)
</code></pre>
<p>At any point you can leave the TUI mode using the following command:</p>
<pre><code>(gdb) tui disable
</code></pre>
<p>We are now "on" the <code>_y = x</code> statement; that statement hasn't been executed yet. This means that <code>x</code>
is initialized but <code>_y</code> could contain anything. Let's inspect <code>x</code> using the <code>print</code> command:</p>
<pre><code>(gdb) print x
$1 = 42
(gdb) print &amp;x
$2 = (*mut i32) 0x20003fe8
(gdb)
</code></pre>
<p>As expected, <code>x</code> contains the value <code>42</code>. The command <code>print &amp;x</code> prints the address of the variable
<code>x</code>.  The interesting bit here is that GDB output shows the type of the reference: <code>*mut i32</code>, a
pointer to a mutable <code>i32</code> value.</p>
<p>If we want to continue the program execution line by line, we can do that using the <code>next</code> command.
Let's proceed to the <code>loop {}</code> statement:</p>
<pre><code>(gdb) next
16          loop {}
</code></pre>
<p>And <code>_y</code> should now be initialized.</p>
<pre><code>(gdb) print _y
$5 = 42
</code></pre>
<p>Instead of printing the local variables one by one you can also use the <code>info locals</code> command:</p>
<pre><code>(gdb) info locals
x = 42
_y = 42
(gdb)
</code></pre>
<p>If we use <code>next</code> again on top of the <code>loop {}</code> statement, we'll get stuck because the program will
never pass that statement. Instead, we'll switch to the disassemble view with the <code>layout asm</code>
command and advance one instruction at a time using <code>stepi</code>. You can always switch back into Rust
source code view later by issuing the <code>layout src</code> command again.</p>
<blockquote>
<p><strong>NOTE</strong> If you used the <code>next</code> or <code>continue</code> command by mistake and GDB got stuck, you can get
unstuck by hitting <code>Ctrl+C</code>.</p>
</blockquote>
<pre><code>(gdb) layout asm
</code></pre>
<p><img src="05-meet-your-software/../assets/gdb-layout-asm.png" alt="GDB session" title="GDB disassemble" /></p>
<p>If you are not using the TUI mode, you can use the <code>disassemble /m</code> command to disassemble the
program around the line you are currently at.</p>
<pre><code>(gdb) disassemble /m
Dump of assembler code for function _ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E:
10      fn main() -&gt; ! {
   0x0000010a &lt;+0&gt;:     sub     sp, #8
   0x0000010c &lt;+2&gt;:     movs    r0, #42 ; 0x2a

11          let _y;
12          let x = 42;
   0x0000010e &lt;+4&gt;:     str     r0, [sp, #0]

13          _y = x;
   0x00000110 &lt;+6&gt;:     str     r0, [sp, #4]

14
15          // infinite loop; just so we don't leave this stack frame
16          loop {}
=&gt; 0x00000112 &lt;+8&gt;:     b.n     0x114 &lt;_ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E+10&gt;
   0x00000114 &lt;+10&gt;:    b.n     0x114 &lt;_ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E+10&gt;

End of assembler dump.
</code></pre>
<p>See the fat arrow <code>=&gt;</code> on the left side? It shows the instruction the processor will execute next.</p>
<p>If not inside the TUI mode on each <code>stepi</code> command GDB will print the statement and the line number
of the instruction the processor will execute next.</p>
<pre><code>(gdb) stepi
16          loop {}
(gdb) stepi
16          loop {}
</code></pre>
<p>One last trick before we move to something more interesting. Enter the following commands into GDB:</p>
<pre><code>(gdb) monitor reset
(gdb) c
Continuing.

Breakpoint 1, init::__cortex_m_rt_main_trampoline () at src/05-meet-your-software/src/main.rs:9
9       #[entry]
(gdb)
</code></pre>
<p>We are now back at the beginning of <code>main</code>!</p>
<p><code>monitor reset</code> will reset the microcontroller and stop it right at the program entry point.
The following <code>continue</code> command will let the program run freely until it reaches the <code>main</code>
function that has a breakpoint on it.</p>
<p>This combo is handy when you, by mistake, skipped over a part of the program that you were
interested in inspecting. You can easily roll back the state of your program back to its very
beginning.</p>
<blockquote>
<p><strong>The fine print</strong>: This <code>reset</code> command doesn't clear or touch RAM. That memory will retain its
values from the previous run. That shouldn't be a problem though, unless your program behavior
depends on the value of <em>uninitialized</em> variables — but that's the definition of Undefined
Behavior (UB).</p>
</blockquote>
<p>We are done with this debug session. You can end it with the <code>quit</code> command.</p>
<pre><code>(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: $PWD/target/thumbv7em-none-eabihf/debug/meet-your-software, Remote target
Ending remote debugging.
[Inferior 1 (Remote target) detached]
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If the default GDB CLI is not to your liking check out <a href="https://github.com/cyrus-and/gdb-dashboard#gdb-dashboard">gdb-dashboard</a>. It uses Python
to turn the default GDB CLI into a dashboard that shows registers, the source view, the assembly
view and other things.</p>
</blockquote>
<p>If you want to learn more about what GDB can do, check out the section <a href="05-meet-your-software/../appendix/2-how-to-use-gdb/">How to use
GDB</a>.</p>
<p>What's next? The high level API I promised.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-it-up"><a class="header" href="#light-it-up">Light it up</a></h1>
<p>We will finish this chapter by making one of the many LEDs on the MB2 light up. In order to get this
task done we will use one of the traits provided by <code>embedded-hal</code>, specifically the <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/digital/v2/trait.OutputPin.html"><code>OutputPin</code></a>
trait which allows us to turn a pin on or off.</p>
<h2 id="the-microbit-leds"><a class="header" href="#the-microbit-leds">The micro:bit LEDs</a></h2>
<p>On the back of the micro:bit you can see a 5x5 square of LEDs, usually called an LED matrix. This
matrix alignment is used so that instead of having to use 25 separate pins to drive every single one
of the LEDs, we can just use 10 (5+5) pins in order to control which column and which row of our
matrix lights up.</p>
<p>Right now we will use the <code>microbit-v2</code> crate to manipulate the LEDs. In the <a href="05-meet-your-software/../06-hello-world/index.html">next chapter</a> we will
go in detail through all of the options available.</p>
<h2 id="actually-lighting-it-up"><a class="header" href="#actually-lighting-it-up">Actually lighting it up!</a></h2>
<p>The code required to light up an LED in the matrix is actually quite simple but it requires a bit of
setup. First take a look at <code>examples/light-it-up.rs</code>; then we can go through it step by step.</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use microbit::board::Board;
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<p>The first few lines until the <code>main</code> function just do some basic imports and setup we mostly looked
at before.  However, the <code>main</code> function looks pretty different to what we have seen up to now.</p>
<p>The first line is related to how most HALs written in Rust work internally.
As discussed before they are built on top of PAC crates which own (in the Rust sense)
all the peripherals of a chip. When we say</p>
<pre><code>let mut board = Board::take().unwrap();
</code></pre>
<p>We take all of these peripherals from the PAC and bind them to a variable. In this specific case we
are not only working with a HAL but with an entire BSP, so this also takes ownership of the Rust
representation of the other chips on the board.</p>
<blockquote>
<p><strong>NOTE</strong>: If you are wondering why we have to call <code>unwrap()</code> here, in theory it is possible for
<code>take()</code> to be called more than once. This would lead to the peripherals being represented by two
separate variables and thus lots of possible confusing behaviour because two variables modify the
same resource. In order to avoid this, PACs are implemented in a way that it would panic if you
tried to take the peripherals twice.</p>
</blockquote>
<p>(Again, if you are confused by all of this, the <a href="05-meet-your-software/../06-hello-world/index.html">next chapter</a> will go through it all again in
greater detail.)</p>
<p>Now we can light the LED connected to <code>row1</code>, <code>col1</code> up by setting the <code>row1</code> pin to high
(i.e. switching it on).  The reason we can leave <code>col1</code> set to low is because of how the LED matrix
circuit works. Furthermore, <code>embedded-hal</code> is designed in a way that every operation on hardware can
possibly return an error, even just toggling a pin on or off. Since that is highly unlikely in our
case, we can just <code>unwrap()</code> the result.</p>
<h2 id="testing-it"><a class="header" href="#testing-it">Testing it</a></h2>
<p>Testing our little program is quite simple. First put it into <code>src/main.rs</code>. Afterwards we simply
have to run the <code>cargo embed</code> command from the last section again, and let it flash just like
before. Then open our GDB and connect to the GDB stub:</p>
<pre><code>$ # Your GDB debug command from the last section
(gdb) target remote :1337
Remote debugging using :1337
cortex_m_rt::Reset () at /home/nix/.cargo/registry/src/github.com-1ecc6299db9ec823/cortex-m-rt-0.6.12/src/lib.rs:489
489     pub unsafe extern "C" fn Reset() -&gt; ! {
(gdb)
</code></pre>
<p>We now let the program run via the GDB <code>continue</code> command: one of the LEDs on the front of the
micro:bit should light up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>In the last section, you wrote a sort of "Hello World" program. But for embedded programmers, the
"real Hello World" is to blink an LED — any LED — on and off once per second. A program that does
this is commonly known as a "blinky".</p>
<p>Why blinky? Because this shows that you have enough control of the board you're working with to
perform this simple task. You can get a program loaded onto the machine and running, you can find
and turn on the appropriate pin on the MCU, you can delay for a fixed amount of time. Once you have
this much control, other tasks become much more straightforward.</p>
<p>In previous chapters, you found out several ways to load a program onto your MB2. Now it's just a
question of which pin you turn on and off, and how you delay between these actions.</p>
<p>Let's start by finding out how to work with the needed pins. There's a path you can follow for this
if you know how to read electronic circuit "schematic" diagrams. You can find the <a href="https://github.com/microbit-foundation/microbit-v2-hardware/blob/main/V2.21/MicroBit_V2.2.1_nRF52820%20schematic.PDF">MB2 schematic</a>,
find an LED on that schematic that you want to turn on and off, and find what GPIO pins on the
nRF52833 are attached to that LED. (The MB2 is a bit unusual in this regard: usually an LED is
attached to just one pin that turns it on or off. The LED "display" on the MB2 is hooked up in a
more complicated way to allow turning on and off combinations of LEDs at once: a feature that we
will be using shortly.)</p>
<p>We will work with the LED in the upper-left corner of the MB2 display. Tracing the <code>ROW1</code> and <code>COL1</code>
wires this LED is connected to, we can see that they go to pins on the nRF52833 labeled
<code>AC17</code>/<code>P0.21</code> and <code>B11</code>/<code>AIN4</code>/<code>P0.28</code>. Digging further through the documentation we find that
<code>AC17</code> and <code>B11</code> are the row and column indices of the physical pins (solder balls, really) on the
bottom of the chip — useless to us. <code>AIN4</code> just means that this pin can act as an "Analog Input",
which is also currently useless to us. (It will come into play later.)</p>
<p>This leaves <code>P0.21</code> and <code>P0.28</code>. These labels correspond to bits in the memory of the nRF52833 that
can be turned on and off to get the LED to light up. Because electronics reasons, if pin <code>P0.21</code> is
turned on (thus outputting 3.3V) and pin <code>P0.28</code> is turned off (thus accepting voltage) the LED will
light up.</p>
<p>But what do we do in software to cause this to occur? We will work at the level of the
<code>nrf52833-hal</code> crate. The Hardware Abstraction Layer (HAL) is a chunk of software designed to make a
particular microcontroller easier to work with. As can be seen from the name, we have one for the
microcontroller on the MB2. It happens to contain everything needed to turn our target LED on.</p>
<p>Take a look at <code>examples/light-up.rs</code> in this chapter's directory, and then try running it.
You could use something fancy like before, but we have it set up so that</p>
<pre><code>cargo run --example light-up
</code></pre>
<p>will load and run your program. That one LED should now be brightly lit!</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let _row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    #[allow(clippy::empty_loop)]
    loop {}
}</code></pre></pre>
<p>Note that we access the Peripheral Access Crate (PAC) for this chip through our HAL crate. There's a
complicated dance needed to get access to our pins. Finally, since we can just initialize the pins
to the right levels, we don't need to set them. Wiggling the pins is a topic for the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toggle-it"><a class="header" href="#toggle-it">Toggle it</a></h1>
<p>Let's turn the LED on and off repeatedly. That's how you make it blink, right?</p>
<p>In <code>examples/fast-blink.rs</code> you'll find the next iteration of our blinky. I've decided to make it
blink the next LED over, while leaving the original LED on. That is an easy change.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let _row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let mut row2 = p0.p0_22.into_push_pull_output(gpio::Level::Low);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    loop {
        row2.set_high().unwrap();
        row2.set_low().unwrap();
    }
}</code></pre></pre>
<p>The <code>embedded-hal</code> crate is being used here to provide the Rust traits needed to set and unset the
LED. This means that this part of the code is portable to any Rust HAL that implements the
<code>embedded-hal</code> traits as ours does.</p>
<p>But wait: neither LED is blinking! The second one is slightly dimmer than the first one, but they
are both solidly on… or are they? Out of the box, the MB2 executes 64 <em>million</em> instructions per
second. Let's assume it takes a few dozen instructions under the hood to turn the LED on or
off. (Maybe possibly that many compiled in debug mode, though way less in release mode. Though the
pins take a while to change state. I don't know.) Anyhow, that second LED is actually turning on and
off hundreds of thousands of times — perhaps millions of times — every second. Your eye just can't
keep up.</p>
<p>We'll need to wait a while between toggles. Turns out waiting is the hardest part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spin-wait"><a class="header" href="#spin-wait">Spin wait</a></h1>
<p>To blink the LED, we need to wait about a half-second between each change. How do we do that?</p>
<p>Well, here's the dumb way. It's not good, but it's a start. Take a look at <code>examples/spin-wait.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm::nop;
use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

fn wait() {
    for _ in 0..4_000_000 {
        nop();
    }
}

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let mut row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    loop {
        wait();
        row1.set_high().unwrap();
        wait();
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>Run this with <code>cargo run --release --example spin-wait</code> — the <code>--release</code> is really important here — and
you should see the LED on your MB2 flash on and off <em>about</em> once per second.</p>
<p>Things you might be wondering:</p>
<ul>
<li>
<p><strong>What are those <code>_</code> characters in that number?</strong> Rust allows these in numbers and ignores them.
It's really convenient to make big numbers more readable. Here we are using them as commas (or
whatever the separator is for groups of three digits in your country).</p>
</li>
<li>
<p><strong>If the nRF52833 is running at 64MHz, why is the wait loop iterating only 4M times? Shouldn't it
be 32M?</strong> The wait loop executes several instructions each time through: the <code>nop</code> (see next
section), some bookkeeping, and a branch back to the start of the loop. The code generated is
roughly this for the first <code>wait()</code> call</p>
<pre><code class="language-asm">.LBB1_4:
    adds r3, #1
    nop
    cmp  r3, r2
    bne  .LBB1_4
</code></pre>
<p>and this for the second</p>
<pre><code class="language-asm">.LBB1_6:
    subs	r3, #1
    nop
    bne	.LBB1_6
</code></pre>
<p>This is only three or four instructions, but the backward branch may cost an extra bit.  Notice
that these <em>are not the same:</em> the compiler chooses to emit different instructions for the first
and second wait loops. See "it varies depending" below.</p>
<p>Still, we're executing about 4 instructions per loop iteration. This means that on our 64MHz CPU a
half-second spin should take 64M/2/4 = 8M iterations to complete. So something is slowing us down
by a factor of 2. What? I dunno. This whole thing is terrible.</p>
</li>
<li>
<p><strong>Why is <code>--release</code> so all-important?</strong> Try without it. Notice that the LED is still flashing on
and off, but with a period of <em>many</em> seconds. The wait loop is now unoptimized and is taking many
instructions each time through.</p>
</li>
<li>
<p><strong>What is that <code>nop()</code> call and why is it there?</strong> We shall answer this in the next section.</p>
</li>
<li>
<p><strong>Why do you refer to this as "the dumb way"?</strong></p>
<ul>
<li>
<p><strong>It isn't precise.</strong> Trying to tune that loop to reliably hit exactly 0.5 seconds is… not
really a thing.</p>
</li>
<li>
<p><strong>It varies depending.</strong> Different CPU? Different compilation flags? Different anything really?
Now the timing has changed.</p>
</li>
<li>
<p><strong>It sucks power.</strong> The CPU is running instructions as fast as it can, just to stay in place.
If there's nothing else for it to do, it should quietly sleep until it is needed again. This
doesn't matter much if you have USB power. But if you hook up your MB2 using the battery pack
you'll really feel this.</p>
</li>
</ul>
</li>
</ul>
<p>In the next section, we'll discuss <code>nop()</code>. After that, we'll talk more about the other things about
our blinky that need improving.</p>
<p>For such a simple program, this is a pretty complicated program. That's why we start with blinky.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nop"><a class="header" href="#nop">NOP</a></h1>
<p>You might wonder what that <code>nop()</code> call is doing in the <code>wait()</code> loop in <code>src/bin/spin-wait.rs</code>.</p>
<p>The answer is that it literally does nothing. The <code>nop()</code> function causes the compiler to put a
<code>NOP</code> Arm machine instruction at that point in the program. <code>NOP</code> is a special instruction that
causes the CPU to skip it. To ignore it. To literally do No OPeration with it (hence the name).</p>
<p>So get rid of that line and recompile the program. Don't forget <code>--release</code> mode. Then run it.</p>
<p>We're back to a slightly darker solid LED again. With no loop body, the compiler's optimizer decided
that <code>wait()</code> function wasn't doing anything. So it just removed it for you at compile time. Thanks
optimizer. You have made my wait loop infinitely fast.</p>
<p>How does <code>nop()</code> do its job? Well, if you look at the implementation of <code>nop()</code> you will find
(after a bunch of digging around) that it is implemented like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asm!("nop", options(nomem, nostack, preserves_flags));
<span class="boring">}</span></code></pre></pre>
<p>The <code>nop()</code> function is "inlined", so when you "call" it an actual Arm <code>NOP</code> assembly instruction is
inserted into your program's code at that point. Because details, this <code>NOP</code> will not be removed or
moved around by the compiler: it will stay right there where you put it.</p>
<p>The ability to insert assembly code into your program where needed is sometimes quite important in
embedded programming. Sometime a CPU will have instructions the compiler doesn't know about, but
that you still need in order to use the CPU effectively. Rust's <code>asm!()</code> directive gives you a way
to do that.</p>
<p>Our spin-wait is still terrible. Let's talk about doing better.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>One of the big advantages of a "bare-metal" embedded system is that you control everything that
happens on your machine. This allows you to have really precise control of time: nothing will slow
you down unless you let it.</p>
<p>However, we've seen that if we really want to get time right, we probably need help. Embedded MCUs
like the nRF52833 all provide this kind of help in the form of "timers". A timer is a peripheral
that, as its name implies, acts like a little clock that keeps very precise track of time.</p>
<p>The nRF52833 contains four timers. If you look at the documentation for the chip, you'll find that
they are pretty complicated to set up and use. Luckily, the HAL provides a wrapper around timers
that makes common uses easy. The most common use of a timer is to delay for a precise amount of
time: just what our <code>wait()</code> function of the previous sections was trying to do.</p>
<p>Take a look at <code>examples/timer-blinky.rs</code>. This code sets up a timer and uses it to delay for 500ms
(0.5s) between each toggle.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use nrf52833_hal::{gpio, pac, timer};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();

    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let mut row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    let mut timer0 = timer::Timer::new(peripherals.TIMER0);

    loop {
        timer0.delay_ms(500);
        row1.set_high().unwrap();
        timer0.delay_ms(500);
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>Run this code with <code>cargo run --release --example timer-blinky</code> and time it with a stopwatch. You'll
find that it is exactly one second for each on-off cycle.</p>
<p>Things you might notice:</p>
<ul>
<li>
<p>We need to use the <code>embedded_hal::Delay</code> trait to get the <code>delay_ms()</code> method we're using.</p>
</li>
<li>
<p>As before, we dig the peripheral out of the PAC peripherals struct and give it to the HAL.</p>
</li>
</ul>
<p>Now we have a production-quality blinky. Let's talk a bit about the implications of all this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portability"><a class="header" href="#portability">Portability</a></h1>
<p>(This section is optional. Feel free to skip to the <a href="06-hello-world/board-support-crate.html">next section</a>, where we clean our code up a bit
and call it a day.)</p>
<p>You may wonder whether all this fancy ecosystem is worth its weight. The setup for our blinky is
pretty fancy, and uses a lot of Rust crates and features for such a simple job.</p>
<p>One cool advantage, though, is that our code becomes really portable. On a different board, the
setup may be different, but the actual blinky loop is identical!</p>
<p>Let's take a look at a blinky for the Sipeed Longan Nano. This is a little $5 board that, like the
MB2, is an embedded board with an MCU. Otherwise, it is completely different: different processor
(the GD32VF103, with a RISC-V instruction set entirely unlike the Arm instruction set we're using),
different peripherals, different board. But it has an LED attached to a GPIO pin, so we can blinky
it.</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use panic_halt as _;
use riscv_rt::entry;
use gd32vf103xx_hal::{pac, prelude::*, delay::McycleDelay};
use embedded_hal::{blocking::delay::DelayMs, digital::v2::OutputPin};

#[entry]
fn main() -&gt; ! {
    let dp = pac::Peripherals::take().unwrap();

    let mut rcu = dp.RCU.configure().ext_hf_clock(8.mhz()).sysclk(108.mhz()).freeze();

    let gpioc = dp.GPIOC.split(&amp;mut rcu);
    let mut led = gpioc.pc13.into_push_pull_output();
    let mut delay = McycleDelay::new(&amp;rcu.clocks);

    loop {
        delay.delay_ms(500);
        led.set_high().unwrap();
        delay.delay_ms(500);
        led.set_low().unwrap();
    }
}</code></pre></pre>
<p>The differences in setup here are partly because different hardware, and partly because this code
uses an older HAL crate that hasn't yet been updated for <code>embedded-hal</code> 1.0. Yet the main loop is
identical as advertised, and the rest of the code is pretty recognizable. Because of the portability
provided by Rust's easy cross-compilation and the embedded Rust ecosystem, blinky is just blinky.</p>
<p>You can find a complete working <a href="https://github.com/pdx-cs-rust/nanoblinky">nanoblinky</a> example on GitHub, if you want to see all the
details or even get your own board and try it yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-support-crate"><a class="header" href="#board-support-crate">Board support crate</a></h1>
<p>Working directly with the PAC and HAL is pretty neat. Most Arm MCUs and many other MCUs that Rust
can compile for have a PAC crate. If you are working with one that does not, writing a PAC crate can
be tedious but is pretty straightforward. Many MCUs that have a PAC crate also have a HAL crate —
again, it's mostly just tedious work to build one if it is absent. Code written at the PAC and HAL
level gives access to the fine details of the MCU.</p>
<p>As we have seen, though, it becomes pretty annoying to keep track of just what is going on at the
interface between our nRF52833 and the rest of our MB2. We have had to read schematics and whatnot
to see how to use our off-board hardware.</p>
<p>A "board support crate" — known in the non-Rust embedded community as a Board Support Package (BSP)
— is a crate built on top of the HAL and PAC for a board to abstract away the details and provide
conveniences. The board support crate we have been working with is the <code>microbit-v2</code> crate.</p>
<p>Let's use <code>microbit-v2</code> to get a final, cleaned up blinky (<code>src/main.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use microbit::hal::{gpio, timer};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let board = microbit::Board::take().unwrap();

    let mut row1 = board.display_pins.row1.into_push_pull_output(gpio::Level::High);
    let _col1 = board.display_pins.col1.into_push_pull_output(gpio::Level::Low);

    let mut timer0 = timer::Timer::new(board.TIMER0);

    loop {
        timer0.delay_ms(500);
        row1.set_high().unwrap();
        timer0.delay_ms(500);
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>In this case, we haven't changed much. Our board support crate has hidden the PAC (for now). More
importantly, it has done so by letting us just use reasonable names for the row and column GPIO pins
for the LED.</p>
<p>The <code>microbit-v2</code> crate provides even fancier support for those "display" LEDs. We will see this
support used soon to do things more fun than blinky.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="led-roulette"><a class="header" href="#led-roulette">LED roulette</a></h1>
<p>Alright, let's build a "real" application. The goal is to get to this display of spinning lights:</p>
<p align="center">
<video src="../assets/roulette_fast.mp4" width="500" loop="true" autoplay="true"/>
</p>
<p>Since working with the LED pins separately is quite annoying (especially if you have to use
basically all of them like here) you can use the <code>microbit-v2</code> BSP crate, discussed previously, to
work with the MB2's LED "display". It works like this (<code>examples/light-it-all.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use microbit::{board::Board, display::blocking::Display, hal::Timer};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();

    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
    let light_it_all = [
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
    ];

    loop {
        // Show light_it_all for 1000ms
        display.show(&amp;mut timer, light_it_all, 1000);
        // clear the display again
        display.clear();
        timer.delay_ms(1000_u32);
    }
}</code></pre></pre>
<p>The Rust array <code>light_it_all</code> shown in the example contains 1 where the LED is on and 0 where it is
off.  The call to <code>show()</code> takes a timer for the BSP display code to use for delaying, a <em>copy</em> of
the array, and a length of time in milliseconds to show this display before returning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge"><a class="header" href="#the-challenge">The challenge</a></h1>
<p>You are now well armed to face our challenge! Again, your application should look like this:</p>
<p align="center">
<video src="../assets/roulette_fast.mp4" width="500" loop="true" autoplay="true"/>
</p>
<p>If you can't exactly see what's happening here it is in a much slower version:</p>
<p align="center">
<video src="../assets/roulette_slow.mp4" width="500" loop="true" autoplay="true"/>
</p>
<p>If you need a hint, <code>templates/solution.rs</code> provides a mostly-filled-out chunk of code to finish. I
would suggest you try it on your own first, though: it should be doable by now…</p>
<p>Got it?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution"><a class="header" href="#my-solution">My solution</a></h1>
<p>What solution did you come up with?</p>
<p>Here's mine. It's probably one of the simplest (but of course not most beautiful) ways to generate
the required matrix:</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use microbit::{board::Board, display::blocking::Display, hal::Timer};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[rustfmt::skip]
const PIXELS: [(usize, usize); 16] = [
    (0, 0),
    (0, 1),
    (0, 2),
    (0, 3),
    (0, 4),
    (1, 4),
    (2, 4),
    (3, 4),
    (4, 4),
    (4, 3),
    (4, 2),
    (4, 1),
    (4, 0),
    (3, 0),
    (2, 0),
    (1, 0),
];

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();

    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
    #[rustfmt::skip]
    let mut leds = [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
    ];

    let mut last_led = (0, 0);

    loop {
        for current_led in PIXELS {
            leds[last_led.0][last_led.1] = 0;
            leds[current_led.0][current_led.1] = 1;
            display.show(&amp;mut timer, leds, 200);
            last_led = current_led;
        }
    }
}</code></pre></pre>
<p>One more thing! Check that your solution also works when compiled in "release" mode:</p>
<pre><code class="language-console">$ cargo embed --release
</code></pre>
<p>If you want to debug your "release" mode binary you'll have to use a different GDB command:</p>
<pre><code class="language-console">$ gdb ../../../target/thumbv7em-none-eabihf/release/led-roulette
</code></pre>
<p>The Rust compiler modifies the machine instructions generated in a release build (sometimes by a
lot) in order to try to make the code faster or smaller. Unfortunately, GDB has a hard time figuring
out what is going on after this. As a result, debugging release builds with GDB can be difficult.</p>
<p>Binary size is something we should always keep an eye on! How big is your solution? You can check
that using the <code>size</code> command on the release binary:</p>
<pre><code class="language-console">$ cargo size --release -- -A
    Finished release [optimized + debuginfo] target(s) in 0.02s
led-roulette  :
section              size        addr
.vector_table         256         0x0
.text                6332       0x100
.rodata               648      0x19bc
.data                   0  0x20000000
.bss                 1076  0x20000000
.uninit                 0  0x20000434
.debug_loc           9036         0x0
.debug_abbrev        2754         0x0
.debug_info         96460         0x0
.debug_aranges       1120         0x0
.debug_ranges       11520         0x0
.debug_str          71325         0x0
.debug_pubnames     32316         0x0
.debug_pubtypes     29294         0x0
.Arm.attributes        58         0x0
.debug_frame         2108         0x0
.debug_line         19303         0x0
.comment              109         0x0
Total              283715
</code></pre>
<p>Your numbers may differ somewhat depending on how your code is built: this is OK.</p>
<p>Know how to read this output? The <code>text</code> section contains the program instructions. The <code>rodata</code>
section contains read-only data stored with the program instructions. The <code>data</code> and <code>bss</code> sections
contain variables statically allocated in RAM (<code>static</code> variables).  If you remember the
specification of the microcontroller on your micro:bit, you should notice that its flash memory is
less than double the size of this extremely simple binary: can this be right?  As we can see from
the size statistics most of the binary is actually made up of debugging related sections. However,
those are not flashed to the microcontroller at any time — after all they aren't relevant for the
execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inputs-and-polling"><a class="header" href="#inputs-and-polling">Inputs and Polling</a></h1>
<p>In earlier chapters, we’ve explored GPIO pins primarily as outputs—driving LEDs on and off. However, GPIO pins can also be configured as inputs, allowing your program to read signals from the physical world, like button presses or switch toggles. In this chapter, we'll learn how to read these input signals and do something useful with them.</p>
<h2 id="reading-button-state"><a class="header" href="#reading-button-state">Reading Button State</a></h2>
<p>The micro:bit v2 has two physical buttons, Button A and Button B, connected to GPIO pins configured as inputs. Specifically, Button A is connected to pin P0.14, and Button B to pin P0.23. (You can verify this from the official <a href="https://tech.microbit.org/hardware/schematic/#v2-pinmap">pinmap table</a>.)</p>
<p>Reading the state of a GPIO input involves checking whether the voltage level at the pin is high (3.3V, logic level 1) or low (0V, logic level 0). Each button on the micro:bit is connected to a pin. When the button is <em>not</em> pressed, that pin is held high; when the button is pressed, the pin is held low.</p>
<p>Let's now apply this knowledge to reading the state of Button A by checking if the button is "low" (pressed).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::InputPin;
use microbit::Board;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();

    let mut button_a = board.buttons.button_a;
    let mut button_state = false;

    loop {
        if button_a.is_low().unwrap() {
            if button_state == false {
                button_state = true;
                rprintln!("Button A pressed");
            }
        } else {
            if button_state == true {
                button_state = false;
                rprintln!("Button A not pressed");
            }
        }
    }
}</code></pre></pre>
<p>We spin looking at the button state, and report anytime that state changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polling"><a class="header" href="#polling">Polling</a></h1>
<p>Now that we've learned how to read GPIO inputs, let's consider how we might use these reads practically. Suppose we want our program to turn on an LED when Button A is pressed and turn it off when Button B is pressed.  We can do this by polling the state of both buttons in a loop, and responding accordingly when a button is read to be pressed.  Here's how we might write this program:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use embedded_hal::digital::{InputPin, OutputPin};
use microbit::hal::timer::Timer;
use microbit::{hal::gpio, Board};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);

    // Configure buttons
    let mut button_a = board.buttons.button_a;
    let mut button_b = board.buttons.button_b;

    // Configure LED (top-left LED at row1, col1)
    let mut row1 = board
        .display_pins
        .row1
        .into_push_pull_output(gpio::Level::Low);
    let _col1 = board
        .display_pins
        .col1
        .into_push_pull_output(gpio::Level::Low);

    loop {
        let on_pressed = button_a.is_low().unwrap();
        let off_pressed = button_b.is_low().unwrap();
        match (on_pressed, off_pressed) {
            // Stay in current state until something is pressed.
            (false, false) =&gt; (),
            // Change to on state.
            (true, false) =&gt; row1.set_high().unwrap(),
            // Change to off state.
            (false, true) =&gt; row1.set_low().unwrap(),
            // Stay in current state until something is released.
            (true, true) =&gt; (),
        }
        timer.delay_ms(10_u32);
    }
}</code></pre></pre>
<p>This method of repeatedly checking inputs in a loop is called polling.  When we check the state of some input, we say we are <em>polling</em> that input.  In this case, we are polling both Button A and Button B.</p>
<p>Polling is simple but allows us to do interesting things based on the external world.  For all of our device's inputs, we can "poll" them in a loop, and respond to the results in some way, one by one.  This kind of method is very conceptually simple and is a good starting point for many projects.  We'll soon find out why polling might not be the best method for all (or even most) cases, but let's try it out first.</p>
<p><strong>Note</strong> "Polling" is often used on two levels of granularity.  At one level, "polling" is used to refer to asking (once) what the state of an input is.  At a higher level, "polling", or perhaps "polling in a loop", is used to refer to asking (repeatedly) what the state of an input is in a simple control flow like the one we used above.  This kind of use of the word to refer to a control flow is used only in the simplest of programs, and seldom used in production (it's not practical as we'll soon see), so generally when embedded engineers talk about polling, they mean the former, i.e. to ask (once) what the state of an input is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-1"><a class="header" href="#the-challenge-1">The challenge</a></h1>
<p>Now it’s your turn to put polling into practice. Your task is to implement a simple program that uses button polling to display directional arrows based on user input:</p>
<ul>
<li>If Button A is pressed, display a left arrow (←) on the LED matrix.</li>
<li>If Button B is pressed, display a right arrow (→) on the LED matrix.</li>
<li>If neither button is pressed, display a single lit LED at the center of the matrix.</li>
</ul>
<p>You'll need to:</p>
<ul>
<li>Initialize the variables for the LED and the buttons.</li>
<li>Continuously poll Button A and Button B.</li>
<li>Update the LED display according to the button state with a clear indication of each state (left, right, or neutral).</li>
</ul>
<p>I hope you don't mess up! It's <em>so</em> hard to share the road with people who don't use their turn signals properly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-1"><a class="header" href="#my-solution-1">My solution</a></h1>
<p>Here's my solution (in <code>src/main.rs</code>).  Hopefully that was pretty easy.  You'll soon see that simple polling like this is not very practical.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::InputPin;
use microbit::{board::Board, display::blocking::Display, hal::Timer};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

// Define LED patterns
const LEFT_ARROW: [[u8; 5]; 5] = [
    [0, 0, 1, 0, 0],
    [0, 1, 0, 0, 0],
    [1, 1, 1, 1, 1],
    [0, 1, 0, 0, 0],
    [0, 0, 1, 0, 0],
];

const RIGHT_ARROW: [[u8; 5]; 5] = [
    [0, 0, 1, 0, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 1, 1, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 1, 0, 0],
];

const CENTER_LED: [[u8; 5]; 5] = [
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
];

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);

    let mut display = Display::new(board.display_pins);
    let mut button_a = board.buttons.button_a;
    let mut button_b = board.buttons.button_b;

    loop {
        if button_a.is_low().unwrap() {
            display.show(&amp;mut timer, LEFT_ARROW, 10);
        } else if button_b.is_low().unwrap() {
            display.show(&amp;mut timer, RIGHT_ARROW, 10);
        } else {
            display.show(&amp;mut timer, CENTER_LED, 10);
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polling-sucks-actually"><a class="header" href="#polling-sucks-actually">Polling sucks, actually</a></h1>
<p>Oh yeah, turn signals usually blink, right?  How could we extend our program to blink the turn signal LED when a button is pressed.  We know how to blink an LED from our Hello World program; we turn on the LED, wait for some time, and then turn it off.  But how can we do this in our main loop while also checking for button presses?  We could try something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        if button_a.is_low().unwrap() {
            // Blink left arrow
            display.show(&amp;LEFT_ARROW);
            timer.delay_ms(500_u32);
            display.show(&amp;BLANK);
            timer.delay_ms(500_u32);
        } else if button_b.is_low().unwrap() {
            // Blink right arrow
            display.show(&amp;RIGHT_ARROW);
            timer.delay_ms(500_u32);
            display.show(&amp;BLANK);
            timer.delay_ms(500_u32);
        } else {
            display.show(&amp;BLANK);
        }
        timer.delay_ms(10_u32);
    }
<span class="boring">}</span></code></pre></pre>
<p>Can you see the problem?  We're trying to do two things at once here:</p>
<ol>
<li>Check for button presses</li>
<li>Blink the LED</li>
</ol>
<p>But the processor can only do one thing at a time.  If we press a button during the blink delay, the processor won't be able to respond until the delay is over and the loop starts again.  As a result, we get a barely-responsive program (try for yourself and see how slow the button is).</p>
<p>A "smarter" program would know that the processor isn't actually doing anything while the blink delay is running. The program could very well do other things while waiting for the delay to finish — namely, checking for button presses.</p>
<h2 id="superloops"><a class="header" href="#superloops">Superloops</a></h2>
<p>The term <em>superloop</em> in embedded systems is used to refer to a main control loop that does a bunch of things in sequence.  It's the natural extension of the simple control flow we've been using so far.  To handle logic that could be perceived as multiple things happening at once, we need to be a bit more clever in how we structure the program so that we can be reasonably responsive to events.</p>
<p>In the case of our turn signal program, where we want to blink the LEDs when a button is pressed, and be quick to stop blinking when the button is released, we can create a "state machine" to represent the various states of the program.  We have three states for the buttons:</p>
<ol>
<li>No button is pressed</li>
<li>Button A is pressed</li>
<li>Button B is pressed</li>
</ol>
<p>We also have three states for the display:</p>
<ol>
<li>No LEDs are on</li>
<li>We are in the active blink state for the display (the LEDs are on)</li>
<li>We are in the inactive blink state for the display (the LEDs are off and waiting to be turned on once the blinking period is over)</li>
</ol>
<p>Since we need to ensure responsiveness, we have to combine these different states.  To fully represent all states of our program, we would have the following:</p>
<ol>
<li>No button is pressed</li>
<li>Button A is pressed, and we are in the active blink state (the left arrow is showing on the display)</li>
<li>Button A is pressed, and we are in the inactive blink state (nothing is showing on the display)</li>
<li>Button B is pressed, and we are in the active blink state (the right arrow is showing on the display)</li>
<li>Button B is pressed, and we are in the inactive blink state (nothing is showing on the display)</li>
</ol>
<p>When either button is first pressed, and we transition from state (1) to either state (2) or (4), we will initialize a timer counter that counts up starting from the moment a button is pressed.  When the timer reaches some threshold amount (like half a second) and the buttons are still pressed, we will then transition to state (3) or (5), respectively, and reinitialize the timer counter.  When the timer again reaches some threshold amount, we will transition back to state (2) or (4), respectively.  If at any time during states (2), (3), (4), or (5) we see that the button is no longer pressed, we transition back to state (1).</p>
<p>Our main superloop control flow will repeatedly poll the buttons, compare our current timer counter (if we have one) to a threshold, and change states if any of the above conditions are met.</p>
<p>We have implemented this superloop as a demonstration (<code>examples/blink-held.rs</code>), but with the state machine simplified only to blink an LED when button A is held.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use embedded_hal::digital::{InputPin, OutputPin};
use microbit::hal::timer::Timer;
use microbit::{hal::gpio, Board};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

const ON_TICKS: u16 = 25;
const OFF_TICKS: u16 = 75;

#[derive(Clone, Copy)]
enum Light {
    Lit(u16),
    Unlit(u16),
}

impl Light {
    fn flip(self) -&gt; Self {
        match self {
            Light::Lit(_) =&gt; Light::Unlit(OFF_TICKS),
            Light::Unlit(_) =&gt; Light::Lit(ON_TICKS),
        }
    }

    fn tick_down(self) -&gt; Self {
        match self {
            Light::Lit(ticks) =&gt; Light::Lit(ticks.max(1) - 1),
            Light::Unlit(ticks) =&gt; Light::Unlit(ticks.max(1) - 1),
        }
    }
}

#[derive(Clone, Copy)]
enum Indicator {
    Off,
    Blinking(Light),
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);

    // Configure buttons
    let mut button_a = board.buttons.button_a;

    // Configure LED (top-left LED at row1, col1)
    let mut row1 = board
        .display_pins
        .row1
        .into_push_pull_output(gpio::Level::Low);
    let _col1 = board
        .display_pins
        .col1
        .into_push_pull_output(gpio::Level::Low);

    let mut state = Indicator::Off;
    loop {
        let button_pressed = button_a.is_low().unwrap();
        match (button_pressed, state) {
            // Turn indicator off when no button.
            (false, _) =&gt; {
                row1.set_low().unwrap();
                state = Indicator::Off;
            }
            // 
            (true, Indicator::Off) =&gt; {
                row1.set_high().unwrap();
                state = Indicator::Blinking(Light::Lit(ON_TICKS));
            }
            (true, Indicator::Blinking(light)) =&gt; {
                match light {
                    Light::Lit(0) | Light::Unlit(0) =&gt; {
                        let light = light.flip();
                        match light {
                            Light::Lit(_) =&gt; row1.set_high().unwrap(),
                            Light::Unlit(_) =&gt; row1.set_low().unwrap(),
                        }
                        state = Indicator::Blinking(light);
                    }
                    Light::Lit(_) | Light::Unlit(_) =&gt; {
                        state = Indicator::Blinking(light.tick_down());
                    }
                }
            }
        }
        timer.delay_ms(10_u32);
    }
}</code></pre></pre>
<p>This is still a bit complex. The 10ms loop delay is more
than adequate to catch button changes.</p>
<p>Superloops work and are often used in embedded systems, but the programmer has to be careful to maintain a high degree of responsiveness to events.  Note how our superloop program is different from the previous simple polling example.  Any state transition step in the superloop as written above should take a fairly small amount of time (e.g. we no longer have delays that could block the processor for long periods of time and cause us to miss any events).  It's not always easy to transform a simple polling program into a superloop where all state transitions are quick and relatively non-blocking, and in these cases, we will have the rely on alternative techniques for handling the different events being executed at the same time.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<p>Doing multiple things at once is called <em>concurrent</em> programming. Concurrency shows up in many places in programming, but especially in embedded systems.  There's a whole host of techniques for implementing systems that interact with peripherals while maintaining a high degree of responsiveness (e.g. interrupt handling, cooperative multitasking, event queues, etc.).  We'll explore some of these in later chapters.</p>
<p>There is a good introduction to concurrency in an embedded context <a href="https://docs.rust-embedded.org/book/concurrency/index.html">here</a> that
you might read through before proceeding.</p>
<p>For now, let's take a deeper look into what's happening when we call <code>button_a.is_low()</code> or <code>display_pins.row1.set_high()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registers"><a class="header" href="#registers">Registers</a></h1>
<p>This chapter is a technical deep-dive. You can safely <a href="09-registers/../10-serial-communication/index.html">skip it</a> for now and come back to it later if
you like. That said, there's a lot of good stuff in here, so I'd recommend you dive in.</p>
<hr />
<p>It's time to explore what calling <code>display_pins.row1.set_high()</code> or <code>button_a_pin.is_high()</code> does under the hood.</p>
<p>In a nutshell, calling <code>display_pins.row1.set_high()</code> just writes to some special memory regions. Go into the <code>09-registers</code> directory
and let's run the starter code statement by statement (<code>src/main.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A magic address!
        const PORT_P0_OUT: u32 = 0x50000504;

        // Turn on the top row
        *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;

        // Turn on the bottom row
        *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;

        // Turn off the top row
        *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);

        // Turn off the bottom row
        *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
    }

    loop {}
}</code></pre></pre>
<p>What's this magic?</p>
<p>The address <code>0x50000504</code> points to a <em>register</em>. A register is a special region of memory that
controls a <em>peripheral</em>. A peripheral is a piece of electronics that sits right next to the
processor within the microcontroller package and provides the processor with extra functionality.
After all, the processor, on its own, can only do math and logic.</p>
<p>This particular register controls General Purpose Input/Output (GPIO) <em>pins</em> (GPIO <em>is</em> a
peripheral) and can be used to <em>drive</em> each of those pins
<em>low</em> or <em>high</em>.</p>
<p>(On the nRF52833 there are more than 32
GPIOs, yet the CPU is 32-bit. Thus, the GPIO
pins are organized in two groups "P0" and "P1", with a set of registers
for reading, writing and configuring each group. The address
above is the address of the output register for the P0 pins.)</p>
<h2 id="an-aside-leds-digital-outputs-and-voltage-levels"><a class="header" href="#an-aside-leds-digital-outputs-and-voltage-levels">An aside: LEDs, digital outputs and voltage levels</a></h2>
<p>Drive? Pin? Low? High?</p>
<p>A pin is a electrical contact. Our microcontroller has several of them and some of them are
connected to Light Emitting Diodes (LEDs). An LED will emit light when voltage is applied to it.  As
the name implies, an LED also acts as a "diode". A diode will only let electricity flow in one
direction. Hook an LED up "forwards" and light comes out. Hook it up "backwards" and nothing
happens.</p>
<p align="center">
<img class="white_bg" height="180" title="LED circuit" src="https://upload.wikimedia.org/wikipedia/commons/c/c9/LED_circuit.svg" />
</p>
<p>Luckily for us, the microcontroller's pins are connected such that we can drive the LEDs the right
way round. All that we have to do is apply enough voltage across the pins to turn the LED on. The
pins attached to the LEDs are normally configured as <em>digital outputs</em> and can output two different
voltage levels: "low", 0 Volts, or "high", 3 Volts. A "high" (voltage) level will turn the LED on
whereas a "low" (voltage) level will turn it off.</p>
<p>These "low" and "high" states map directly to the concept of digital logic. "low" is <code>0</code> or <code>false</code>
and "high" is <code>1</code> or <code>true</code>. This is why this pin configuration is known as digital output.</p>
<p>The opposite of a digital output is a digital input.  In the same way that a digital output can be either <code>0</code> or <code>1</code>, a digital input can be either <code>0</code> or <code>1</code>.  The difference is that digital outputs can drive a voltages, but digital inputs <em>read</em> a voltage.  When the microcontroller reads a voltage level above a high threshold, it will interpret that as a <code>1</code> and when it reads a voltage level below a low threshold, it will interpret that as a <code>0</code>.</p>
<hr />
<p>OK. But how can one find out what this register does? Time to RTRM (Read the Reference Manual)!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtrm-reading-the-reference-manual"><a class="header" href="#rtrm-reading-the-reference-manual">RTRM: Reading The Reference Manual</a></h1>
<p>We have previously seen the GPIO pins on the nRF52833. On this chip (and on many others) the GPIO
pins are grouped into <em>ports</em>. There are two ports, Port 0 and Port 1, abbreviated to <code>P0</code> and <code>P1</code>
respectively. The pins within each port are named with numbers starting from 0. Port 0 has 32 pins,
named <code>P0.00</code> to <code>P0.31</code>, and Port 1 has 10 pins, named <code>P1.00</code> to <code>P1.09</code>.</p>
<p>The first thing we have to remember out is which pin is connected to which LED.  We previously did
this by tracing the schematic. That turns out to be hard mode: the required information is in the
MB2 <a href="https://tech.microbit.org/hardware/schematic/#v2-pinmap">pinmap table</a>.</p>
<p>The table says:</p>
<ul>
<li><code>ROW1</code>, the top LED row, is connected to the pin <code>P0.21</code>. <code>P0.21</code> is the short form of: Pin 21 on Port 0.</li>
<li><code>ROW5</code>, the bottom LED row, is connected to the pin <code>P0.19</code>.</li>
</ul>
<p>Up to this point, we know that we want to change the state of the pins <code>P0.21</code> and <code>P0.19</code> to turn
the top and bottom rows on and off. These pins are part of Port 0 so we'll use the <code>P0</code> peripheral
to set them up.</p>
<p>Each peripheral has a register <em>block</em> associated with it. A register block is a collection of
registers allocated in contiguous memory. The address at which the register block starts is known as
its base address. We need to figure out what's the base address of the <code>P0</code> peripheral. That
information is in the following section of the microcontroller <a href="https://docs.nordicsemi.com/bundle/nRF52833_PS_v1.6/resource/nRF52833_PS_v1.6.pdf">Product Specification</a>:</p>
<blockquote>
<p>Section 4.2.4 Instantiation - Page 22</p>
</blockquote>
<p>The table says that base address of the <code>P0</code> register block is <code>0x5000_0000</code>.</p>
<p>Each peripheral also has its own section in the documentation. Each of these sections ends with a
table of the registers that the peripheral's register block contains. For the <code>GPIO</code> family of
peripheral, that table is in:</p>
<blockquote>
<p>Section 6.8.2 Registers - Page 144</p>
</blockquote>
<p><code>OUT</code> is the register which we will be using to set/reset. Its offset value is <code>0x504</code> from the base
address of the <code>P0</code>. We can look up <code>OUT</code> in the reference manual.</p>
<p>That register is specified right under the <code>GPIO</code> registers table:</p>
<blockquote>
<p>Subsection 6.8.2.1 OUT - Page 145</p>
</blockquote>
<p>Anyway, <code>0x5000_0000</code> + <code>0x504</code> = <code>0x50000504</code>. That looks familiar! Finally!</p>
<p>This is the register we were writing to. The documentation says some interesting things. First, this
register can both be written to and read from. Next, the register is a 32-bit piece of memory, and
each bit represents the state of the corresponding pin. That means that bit 19 matches pin 19, for
instance.  Setting the bit to 1 will enable the pin output, and setting it to 0 will reset
it. Furthermore, we can see that all pin outputs are disabled by default, as the reset value of all
bits is 0.</p>
<p>We'll use GDB's <code>examine</code> command: <code>x</code>. Depending on the configuration of your GDB server,
GDB will refuse to read memory that isn't specified. You can disable this behaviour by running:</p>
<pre><code>set mem inaccessible-by-default off
</code></pre>
<p>So here we go. First turn off the <code>inaccessible-by-default</code> flag, then set a couple of breakpoints, reset the device and halt.</p>
<pre><code>(gdb) set mem inaccessible-by-default off
(gdb) break 16
Breakpoint 1 at 0x172: file src/07-registers/src/main.rs, line 16.
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) break 19
Breakpoint 2 at 0x17c: file src/07-registers/src/main.rs, line 19.
(gdb) break 22
Breakpoint 3 at 0x184: file src/07-registers/src/main.rs, line 22.
(gdb) break 25
Breakpoint 4 at 0x18c: file src/07-registers/src/main.rs, line 25.
(gdb) monitor reset halt
Resetting and halting target
Target halted
</code></pre>
<p>All right. Let's continue until the first breakpoint, right before line 16, and print the contents
of the register at address <code>0x50000504</code>.</p>
<pre><code>(gdb) c
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:16
16              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;
(gdb) x 0x50000504
0x50000504:     0x00000000
</code></pre>
<p>Ok, we see that the register's value is <code>0x00000000</code> or <code>0</code> at this point. This corresponds with the
data in the product specification, which says that <code>0</code> is the 'reset value' of this register. That
means that once the MCU resets, the register will have <code>0</code> as its value.</p>
<p>Let's go on. This line consists of multiple instructions (reading, bitwise ORing and writing), so we
need to instruct the debugger to continue execution more than once, until we hit the next
breakpoint.</p>
<pre><code>(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x00000174 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:16
16              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;
(gdb) c
Continuing.

Breakpoint 2, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:19
19              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;
</code></pre>
<p>We've stopped right before line 19, meaning that line 16 is fully executed at this point. Let's have
a look at the <code>OUT</code> register's contents again:</p>
<pre><code>(gdb) x 0x50000504
0x50000504:     0x00200000
</code></pre>
<p>The value of the <code>OUT</code> register is <code>0x00200000</code> at this point, which is <code>2097152</code> in decimal, or
<code>2^21</code>. That means that bit 21 is set to 1, and the rest of the bits is set to 0. That corresponds
to the code on line 16, which writes <code>1 &lt;&lt; 21</code>, or a 1 shifted left 21 positions, bitwise ORed with
<code>OUT</code>s current value (which was 0), to the <code>OUT</code> register.</p>
<p>Writing <code>1 &lt;&lt; 21</code> (<code>OUT[21]= 1</code>) to <code>OUT</code> sets <code>P0.21</code> <em>high</em>. That turns the top LED row
<em>on</em>. Check that the top row is now indeed lit up.</p>
<pre><code>(gdb) c
Continuing.
</code></pre>
<p>Yeah, I was gonna say that. Now, hit 'c' another time to continue execution up to the next
breakpoint and print its value.</p>
<pre><code>Program received signal SIGINT, Interrupt.
0x0000017e in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:19
19              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;
(gdb) c
Continuing.

Breakpoint 3, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:22
22              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);
(gdb) x 0x50000504
0x50000504:     0x00280000
</code></pre>
<p>On line 19, we've set bit 21 of <code>OUT</code> to 1, keeping bit 19 as is. The result is <code>0x00280000</code>, which
is <code>2621440</code> in decimal, or <code>2^19 + 2^21</code>, meaning that both bit 19 and bit 21 is set to 1.</p>
<p>Writing <code>1 &lt;&lt; 19</code> (<code>OUT[19]= 1</code>) to <code>OUT</code> sets <code>P0.19</code> <em>high</em>. That turns the bottom LED row
<em>on</em>. As such, the bottom row should now be lit up.</p>
<p>The following lines turn the rows off again. First the top row, then the bottom row. This time,
we're doing a bitwise AND operation, combined with a bitwise NOT. We calculate <code>!(1 &lt;&lt; 21)</code>, which
is all bits set to 1, except for bit 21. Next, we bitwise AND that with the current value of <code>OUT</code>,
ensuring that only bit 21 is set to 0, keeping the value of the other bits intact.</p>
<p>Continue execution and check that the reported values of the <code>OUT</code> register matches what you
expect. You can press <code>CTRL+C</code> to pause execution once the device enters the endless loop at the end
of the <code>main</code> function.</p>
<pre><code>(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x00000186 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:22
22              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);
(gdb) c
Continuing.

Breakpoint 4, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:25
25              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
(gdb) x 0x50000504
0x50000504:     0x00080000
(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x0000018e in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:25
25              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
(gdb) c
Continuing.
^C
Program received signal SIGINT, Interrupt.
0x00000196 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:28
28          loop {}
(gdb) x 0x50000504
0x50000504:     0x00000000
</code></pre>
<p>And at this points all LEDs should be turned off again!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misoptimization"><a class="header" href="#misoptimization">(mis)Optimization</a></h1>
<p>Reads/writes to registers are quite special. I may even dare to say that they are embodiment of side
effects. In the previous example we wrote four different values to the same register. If you didn't
know that address was a register, you may have simplified the logic to just write the final value
<code>0x00000000</code> into the register.</p>
<p>Actually, LLVM, the compiler's backend / optimizer, does not know we are dealing with a register and
will merge the writes thus changing the behavior of our program. Let's check that really quick.</p>
<p>First, we'll use cargo objdump to get us the assembly of the build artifacts from both the optimized
and the non-optimized build.</p>
<pre><code># Non-optimized
cargo objdump -- --disassemble --no-show-raw-insn --source &gt; debug.dump
# Optimized
cargo objdump --release -- --disassemble --no-show-raw-insn --source &gt; release.dump
</code></pre>
<p>Let's see what's in there. Specifically, let's try to find the assembly that manipulates the <code>OUT</code>
register.</p>
<p>First, let's have a look at the contents of <code>debug.dump</code>, the assembly from the non-optimized build.
I skipped a bunch and added my comments behind the <code>; &lt;--</code>, indicating the line number in the source
code that corresponds to the instruction.</p>
<pre><code>$ cat debug.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	sub	sp, #0x8
     166:      	bl	0x198 &lt;registers::init::hb6346637538e8ec5&gt; @ imm = #0x2e
     16a:      	movw	r1, #0x504        ; &lt;-- Load lower half of `OUT` register address into register `r1`
     16e:      	movt	r1, #0x5000       ; &lt;-- Load upper half of `OUT` register address into register `r1`
     172:      	str	r1, [sp, #0x4]
     174:      	ldr	r0, [r1]          ; &lt;-- (16) Load value at the address in `r1` into `r0`.
     176:      	orr	r0, r0, #0x200000 ; &lt;-- (16) Bitwise OR the value in `r0` with `0x200000`, and store in `r0`
     17a:      	str	r0, [r1]          ; &lt;-- (16) Store contents of `r0` in memory at address from `r1`
     17c:      	ldr	r0, [r1]          ; &lt;-- (19) Load value at the address in `r1` into `r0`.
     17e:      	orr	r0, r0, #0x80000  ; &lt;-- (19) Bitwise OR the value in `r0` with `0x80000`, and store in `r0`
     182:      	str	r0, [r1]          ; &lt;-- (19) Store contents of `r0` in memory at address from `r1`
     184:      	ldr	r0, [r1]          ; &lt;-- (22) Load value at the address in `r1` into `r0`.
     186:      	bic	r0, r0, #0x200000 ; &lt;-- (22) Bitwise AND the value in `r0` with bitwise complement of `0x200000`, and store in `r0`
     18a:      	str	r0, [r1]          ; &lt;-- (22) Store contents of `r0` in memory at address from `r1`
     18c:      	ldr	r0, [r1]          ; &lt;-- (25) Load value at the address in `r1` into `r0`.
     18e:      	bic	r0, r0, #0x80000  ; &lt;-- (25) Bitwise AND the value in `r0` with bitwise complement of `0x80000`, and store in `r0`
     192:      	str	r0, [r1]          ; &lt;-- (25) Store contents of `r0` in memory at address from `r1`
     194:      	b	0x196 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf+0x36&gt; @ imm = #-0x2
     196:      	b	0x196 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf+0x36&gt; @ imm = #-0x4
[...]
</code></pre>
<p>As you can see, the non-optimized assembly contains 4 loads, 4 stores, and 4 bit manipulation
instructions.  Those correspond nicely with the code we wrote. Now, let's have a look at the
optimized assembly.</p>
<pre><code>$ cat release.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x17a &lt;registers::init::h4390f1d4f8a071f7&gt; @ imm = #0x12
     168:      	movw	r0, #0x504          ; &lt;-- Load lower half of `OUT` register address into register `r0`
     16c:      	movt	r0, #0x5000         ; &lt;-- Load upper half of `OUT` register address into register `r0`
     170:      	ldr	r1, [r0]                ; &lt;-- (?) Load value at the address in `r0` into `r1`.
     172:      	bic	r1, r1, #0x280000       ; &lt;-- (?) Bitwise AND the value in `r1` with bitwise complement of `0x280000`, and store in `r1`
     176:      	str	r1, [r0]                ; &lt;-- (?) Store contents of `r0` in memory at address from `r0`
     178:      	b	0x178 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485+0x18&gt; @ imm = #-0x4
[...]
</code></pre>
<p>Huh? Just a single load - bit manipulate - store?  The state of the LEDs didn't change this time!
The <code>str</code> instruction is the one that writes a value to the register. Our <em>debug</em> (unoptimized)
program had four of them, one for each write to the register, but the <em>release</em> (optimized) program
only has one.</p>
<p>How do we prevent LLVM from misoptimizing our program? We use <em>volatile</em> operations instead of plain
reads/writes (<code>examples/volatile.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A magic address!
        const PORT_P0_OUT: u32 = 0x50000504;

        // Turn on the top row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out | 1 &lt;&lt; 21);

        // Turn on the bottom row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out | 1 &lt;&lt; 19);

        // Turn off the top row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out &amp; !(1 &lt;&lt; 21));

        // Turn off the bottom row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out &amp; !(1 &lt;&lt; 19));
    }

    loop {}
}</code></pre></pre>
<p>Let's run cargo objdump once again, with optimizations enabled.</p>
<pre><code>cargo objdump -q --release --bin volatile -- --disassemble --no-show-raw-insn  &gt; release.volatile.dump
</code></pre>
<p>All right, now have a look at what's inside:</p>
<pre><code>$ cat release.volatile.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x192 &lt;registers::init::h4390f1d4f8a071f7&gt; @ imm = #0x2a
     168:      	movw	r0, #0x504
     16c:      	movt	r0, #0x5000
     170:      	ldr	r1, [r0]
     172:      	orr	r1, r1, #0x200000
     176:      	str	r1, [r0]
     178:      	ldr	r1, [r0]
     17a:      	orr	r1, r1, #0x80000
     17e:      	str	r1, [r0]
     180:      	ldr	r1, [r0]
     182:      	bic	r1, r1, #0x200000
     186:      	str	r1, [r0]
     188:      	ldr	r1, [r0]
     18a:      	bic	r1, r1, #0x80000
     18e:      	str	r1, [r0]
     190:      	b	0x190 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485+0x30&gt; @ imm = #-0x4
[...]
</code></pre>
<p>Hey, look at that! Now we've got our four load - manipulate - store cycles back.
Step through the code once again using GDB to see the volatile operations in action!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0xbaaaaaad-address"><a class="header" href="#0xbaaaaaad-address"><code>0xBAAAAAAD</code> address</a></h1>
<p>Not all the peripheral memory can be accessed. Look at this program (<code>examples/bad.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        ptr::read_volatile(0x5000_A784 as *const u32);
    }

    loop {}
}</code></pre></pre>
<p>This address is close to the <code>OUT</code> address we used before but this address is <em>invalid</em>, in the
sense that there's no register at this address.</p>
<p>Now, let's try it.</p>
<pre><code class="language-console">$ cargo run
(..)
Resetting and halting target
Target halted
(gdb) continue
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main_trampoline () at src/07-registers/src/main.rs:9
9	#[entry]
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:10
10	fn main() -&gt; ! {
(gdb) continue
Continuing.

Breakpoint 3, cortex_m_rt::HardFault_ (ef=0x2001ffb8) at src/lib.rs:1046
1046	    loop {}
(gdb) 
</code></pre>
<p>We tried to do an invalid operation, reading memory that doesn't exist, so the processor raised an
<em>exception</em>: a <em>hardware</em> exception.</p>
<p>In most cases, exceptions are raised when the processor attempts to perform an invalid operation.
Exceptions break the normal flow of a program and force the processor to execute an <em>exception
handler</em>, which is just a function/subroutine.</p>
<p>There are different kind of exceptions. Each kind of exception is raised by different conditions and
each one is handled by a different exception handler.</p>
<p>The <code>registers</code> crate depends on the <code>cortex-m-rt</code> crate which defines a default <em>hard fault</em>
handler, named <code>HardFault_</code>, that handles the "invalid memory address" exception. <code>embed.gdb</code> placed
a breakpoint on <code>HardFault</code>; that's why the debugger halted your program while it was executing the
exception handler.  We can get more information about the exception from the debugger. Let's see:</p>
<pre><code>(gdb) list
1040  #[allow(unused_variables)]
1041	#[doc(hidden)]
1042	#[cfg_attr(cortex_m, link_section = ".HardFault.default")]
1043	#[no_mangle]
1044	pub unsafe extern "C" fn HardFault_(ef: &amp;ExceptionFrame) -&gt; ! {
1045	    #[allow(clippy::empty_loop)]
1046	    loop {}
1047	}
1048	
1049	#[doc(hidden)]
1050	#[no_mangle]
</code></pre>
<p><code>ef</code> is a snapshot of the program state right before the exception occurred. Let's inspect it:</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x5000a784,
  r1: 0x3,
  r2: 0x2001ff24,
  r3: 0x0,
  r12: 0x1,
  lr: 0x4403,
  pc: 0x43ea,
  xpsr: 0x1000000
}
</code></pre>
<p>There are several fields here but the most important one is <code>pc</code>, the Program Counter register.  The
address in this register points to the instruction that generated the exception. Let's disassemble
the program around the bad instruction.</p>
<pre><code>(gdb) disassemble /m ef.pc
Dump of assembler code for function core::ptr::read_volatile&lt;u32&gt;:
1654	pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T {
   0x000043d2 &lt;+0&gt;:	push	{r7, lr}
   0x000043d4 &lt;+2&gt;:	mov	r7, sp
   0x000043d6 &lt;+4&gt;:	sub	sp, #16
   0x000043d8 &lt;+6&gt;:	str	r0, [sp, #4]
   0x000043da &lt;+8&gt;:	str	r0, [sp, #8]

1655	    // SAFETY: the caller must uphold the safety contract for `volatile_load`.
1656	    unsafe {
1657	        assert_unsafe_precondition!(
   0x000043dc &lt;+10&gt;:	b.n	0x43de &lt;core::ptr::read_volatile&lt;u32&gt;+12&gt;
   0x000043de &lt;+12&gt;:	ldr	r0, [sp, #4]
   0x000043e0 &lt;+14&gt;:	movs	r1, #4
   0x000043e2 &lt;+16&gt;:	bl	0x43f4 &lt;core::ptr::read_volatile::precondition_check&gt;
   0x000043e6 &lt;+20&gt;:	b.n	0x43e8 &lt;core::ptr::read_volatile&lt;u32&gt;+22&gt;

1658	            check_language_ub,
1659	            "ptr::read_volatile requires that the pointer argument is aligned and non-null",
1660	            (
1661	                addr: *const () = src as *const (),
1662	                align: usize = align_of::&lt;T&gt;(),
1663	            ) =&gt; is_aligned_and_not_null(addr, align)
1664	        );
1665	        intrinsics::volatile_load(src)
   0x000043e8 &lt;+22&gt;:	ldr	r0, [sp, #4]
   0x000043ea &lt;+24&gt;:	ldr	r0, [r0, #0]          ; &lt;-- That's the one!
   0x000043ec &lt;+26&gt;:	str	r0, [sp, #12]
   0x000043ee &lt;+28&gt;:	ldr	r0, [sp, #12]

1666	    }
1667	}
   0x000043f0 &lt;+30&gt;:	add	sp, #16
   0x000043f2 &lt;+32&gt;:	pop	{r7, pc}

End of assembler dump.

</code></pre>
<p>The exception was caused by the <code>ldr r0, [r0, #0]</code> instruction, a read instruction. The instruction
tried to read the memory at the address indicated by the <code>r0</code> <em>CPU register</em>. By the way, a CPU
(processor) register not a memory mapped register; it doesn't have an associated address like, say,
<code>OUT</code>.</p>
<p>Wouldn't it be nice if we could check what the value of the <code>r0</code> register was right at the instant
when the exception was raised? Well, we already did! The <code>r0</code> field in the <code>ef</code> value we printed
before is the value of <code>r0</code> register had when the exception was raised. Here it is again:</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x5000a784,
  r1: 0x3,
  r2: 0x2001ff24,
  r3: 0x0,
  r12: 0x1,
  lr: 0x4403,
  pc: 0x43ea,
  xpsr: 0x1000000
}
</code></pre>
<p><code>r0</code> contains the value <code>0x5000_A784</code> which is the invalid address we called the <code>read_volatile</code>
function with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spooky-action-at-a-distance"><a class="header" href="#spooky-action-at-a-distance">Spooky action at a distance</a></h1>
<p><code>OUT</code> is not the only register that can control the pins of Port E. The <code>OUTSET</code> register also lets
you change the value of the pins, as can <code>OUTCLR</code>. However, <code>ODRSET</code> and <code>OUTCLR</code> don't let you
retrieve the current output status of Port E.</p>
<p><code>OUTSET</code> is documented in:</p>
<blockquote>
<p>Subsection 6.8.2.2. OUTSET - Page 145</p>
</blockquote>
<p>Let's look at below program. The key to this program is <code>fn print_out</code>. This function prints the
current value in <code>OUT</code> to the <code>RTT</code> console (<code>examples/spooky.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::{entry, rprintln};

// Print the current contents of P0.OUT
fn print_out() {
    const P0_OUT: u32 = 0x5000_0504;

    let out = unsafe { ptr::read_volatile(P0_OUT as *const u32) };

    rprintln!("P0.OUT = {:#08x}", out);
}

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A bunch of magic addresses!
        const P0_OUTSET: u32 = 0x5000_0508;
        const P0_OUTCLR: u32 = 0x5000_050C;

        // Print the initial contents of OUT
        print_out();

        // Turn on the top LED row
        ptr::write_volatile(P0_OUTSET as *mut u32, 1 &lt;&lt; 21);
        print_out();

        // Turn on the bottom LED row
        ptr::write_volatile(P0_OUTSET as *mut u32, 1 &lt;&lt; 19);
        print_out();

        // Turn off the top LED row
        ptr::write_volatile(P0_OUTCLR as *mut u32, 1 &lt;&lt; 21);
        print_out();

        // Turn off the bottom LED row
        ptr::write_volatile(P0_OUTCLR as *mut u32, 1 &lt;&lt; 19);
        print_out();
    }

    loop {}
}</code></pre></pre>
<p>You'll see this if you run this program:</p>
<pre><code class="language-console">$ cargo embed
# cargo-embed's console
(..)
15:13:24.055: P0.OUT = 0x000000
15:13:24.055: P0.OUT = 0x200000
15:13:24.055: P0.OUT = 0x280000
15:13:24.055: P0.OUT = 0x080000
15:13:24.055: P0.OUT = 0x000000
</code></pre>
<p>Side effects! Although we are reading the same address multiple times without actually modifying it,
we still see its value change every time <code>OUTSET</code> or <code>OUTCLR</code> is written to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-manipulation"><a class="header" href="#type-safe-manipulation">Type safe manipulation</a></h1>
<p>One of the registers of <code>P0</code>, the <code>IN</code> register, is documented as a read-only register.</p>
<blockquote>
<p>6.8.2.4 IN - Pages 145 and 146</p>
</blockquote>
<p>Note that in the 'Access' column of the table, only the 'R' is given for this register.  We are not
supposed to write to this register or Bad Stuff May Happen.</p>
<p>Registers have different read/write permissions. Some of them are write only, others can be read and
written to and there must be others that are read only.</p>
<p>Directly working with hexadecimal addresses is also error-prone. You already saw that trying to
access an invalid memory address caused an exception which disrupted the execution of our program.</p>
<p>Wouldn't it be nice if we had an API to manipulate registers in a "safe" manner? Ideally, the API
should encode these three points I've mentioned: No messing around with the actual addresses, should
respect read/write permissions and should prevent modification of the reserved parts of a register.</p>
<p>Well, we do! <code>registers::init()</code> actually returns a value that provides a type safe API to
manipulate the registers of the <code>P0</code> and <code>P1</code> ports.</p>
<p>As you may remember: a group of registers associated to a peripheral is called register block, and
it's located in a contiguous region of memory. In this type safe API each register block is modeled
as a <code>struct</code> where each of its fields represents a register. Each register field is a different
newtype over e.g. <code>u32</code> that exposes a combination of the following methods: <code>read</code>, <code>write</code> or
<code>modify</code> according to its read/write permissions. Finally, these methods don't take primitive values
like <code>u32</code>, instead they take yet another newtype that can be constructed using the builder pattern
and that prevent the modification of the reserved parts of the register.</p>
<p>The best way to get familiar with this API is to port our running example to it
(<code>examples/type-safe.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    let (p0, _p1) = registers::init();

    // Turn on the top row
    p0.out.modify(|_, w| w.pin21().set_bit());

    // Turn on the bottom row
    p0.out.modify(|_, w| w.pin19().set_bit());

    // Turn off the top row
    p0.out.modify(|_, w| w.pin21().clear_bit());

    // Turn off the bottom row
    p0.out.modify(|_, w| w.pin19().clear_bit());

    loop {}
}</code></pre></pre>
<p>First thing you notice: There are no magic addresses involved. Instead we use a more human friendly
way, <code>p0.out</code>, to refer to the <code>OUT</code> register in the <code>P0</code> port register block.</p>
<p>The register block has a <a href="https://docs.rs/svd2rust/latest/svd2rust/#modify"><code>modify</code></a> method that takes a closure. Before this closure is called, the
<code>OUT</code> register's value is read and passed to the closure as the <code>r</code> parameter. Given the value of
<code>r</code>, you can manipulate <code>w</code> to the desired new value of the register using its methods. The result
is written to the register once the closure returns. In our case, the current value of the register
is also passed in the <code>w</code> parameter, allowing us to just manipulate <code>w</code> when we want to keep the
rest of the register bits as is.</p>
<p>The <code>modify</code> method is defined for registers that allow both write and read access. If you'd like to
just read a register's value, but not update it, you can use the <a href="https://docs.rs/svd2rust/latest/svd2rust/#read"><code>read</code></a> method. Or, if you simply
want to write a register value without reading, there's the <a href="https://docs.rs/svd2rust/latest/svd2rust/#write"><code>write</code></a> method.</p>
<p>Read-only registers only expose <code>read</code>, and write-only registers only expose <code>write</code>. This prevents
users from accessing a register in a way that's not allowed, and therefore you don't need to wrap
the calls in an <code>unsafe</code> block. And you don't need to figure out the exact register address and bit
positions yourself!</p>
<p>Let's run this program! There's some interesting stuff we can do <em>while</em> debugging the program.</p>
<p><code>p0</code> is a reference to the <code>P0</code> port's register block. <code>print p0</code> will return the base address of
the register block, and <code>print *p0</code> will print its value.</p>
<pre><code>$ cargo run
(..)
Target halted
(gdb) set mem inaccessible-by-default off
(gdb) break main.rs:12
Breakpoint 4 at 0x162: main.rs:12. (2 locations)
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
cortex_m_rt::DefaultPreInit () at src/lib.rs:1058
1058	pub unsafe extern "C" fn DefaultPreInit() {}
(gdb) continue
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main_trampoline () at src/07-registers/src/main.rs:7
7	#[entry]
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:8
8	fn main() -&gt; ! {
(gdb) continue
Continuing.

Breakpoint 4.2, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:12
12	    p0.out.modify(|_, w| w.pin21().set_bit());
(gdb) print *p0                                               ; ⬅️ Printing `*p0` here!
$1 = nrf52833_pac::p0::RegisterBlock {
  _reserved0: [0 &lt;repeats 1284 times&gt;],
  out: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::out::OUT_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::out::OUT_SPEC&gt;
  },
  outset: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::outset::OUTSET_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::outset::OUTSET_SPEC&gt;
  },
  outclr: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::outclr::OUTCLR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::outclr::OUTCLR_SPEC&gt;
  },
  in_: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::in_::IN_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::in_::IN_SPEC&gt;
  },
  dir: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dir::DIR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dir::DIR_SPEC&gt;
  },
  dirset: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dirset::DIRSET_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dirset::DIRSET_SPEC&gt;
  },
  dirclr: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dirclr::DIRCLR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dirclr::DIRCLR_SPEC&gt;
  },
  latch: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::latch::LATCH_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::latch::LATCH_SPEC&gt;
  },
  detectmode: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::detectmode::DETECTMODE_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::detectmode::DETECTMODE_SPEC&gt;
  },
  _reserved9: [0 &lt;repeats 472 times&gt;],
  pin_cnf: [nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    } &lt;repeats 11 times&gt;, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }]
}


</code></pre>
<p>All these newtypes and closures sound like they'd generate large, bloated programs. If you actually
compile the program in release mode with <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">LTO</a> enabled, though, you'll see exactly the same
instructions that the "unsafe" version that used <code>write_volatile</code> and hexadecimal addresses had!</p>
<p>Use <code>cargo objdump</code> to grab the assembler code to <code>release.type-safe.dump</code>:</p>
<pre><code class="language-console">cargo objdump -q --release --bin type-safe -- --disassemble --no-show-raw-insn  &gt; release.type-safe.dump
</code></pre>
<p>Then search for <code>main</code> in <code>release.type-safe.dump</code></p>
<pre><code>00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x192 &lt;registers::init::hec71dddc40be11b5&gt; @ imm = #0x2a
     168:      	movw	r0, #0x504
     16c:      	movt	r0, #0x5000
     170:      	ldr	r1, [r0]
     172:      	orr	r1, r1, #0x200000
     176:      	str	r1, [r0]
     178:      	ldr	r1, [r0]
     17a:      	orr	r1, r1, #0x80000
     17e:      	str	r1, [r0]
     180:      	ldr	r1, [r0]
     182:      	bic	r1, r1, #0x200000
     186:      	str	r1, [r0]
     188:      	ldr	r1, [r0]
     18a:      	bic	r1, r1, #0x80000
     18e:      	str	r1, [r0]
     190:      	b	0x190 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd+0x30&gt; @ imm = #-0x4
</code></pre>
<p>You can validate that this yields the exact same binary as the one with the calls to
<code>ptr::read_volatile</code> and <code>ptr::write_volatile</code>.</p>
<p>The best part of all this is that nobody had to write a single line of code to implement the GPIO
API. All the code was automatically generated from a System View Description (SVD) file using the
<a href="https://crates.io/crates/svd2rust">svd2rust</a> tool. This SVD file is actually an XML file that microcontroller vendors provide and that
contains the register maps of their microcontrollers. The file contains the layout of register
blocks, the base addresses, the read/write permissions of each register, the layout of the
registers, whether a register has reserved bits and lots of other useful information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-communication"><a class="header" href="#serial-communication">Serial communication</a></h1>
<a href="https://en.wikipedia.org/wiki/File:Serial_port.jpg">
<p align="center">
<img height="240" title="Standard serial port connector DE-9" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Serial_port.jpg/800px-Serial_port.jpg" />
</p>
</a>
<p align="center">
<em>This is what we'll be using. I hope your computer has one!</em>
</p>
<p>Nah, don't worry. This connector, the DE-9, went out of fashion on PCs quite some time ago; it got
replaced by the Universal Serial Bus (USB). We won't be dealing with the DE-9 connector itself but
with the communication protocol that this cable is/was usually used for.</p>
<p>So what's this <a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication"><em>serial communication</em></a>? It's an <em>asynchronous</em> communication protocol where
two devices exchange data <em>serially</em>, as in one bit at a time, using two data lines (plus a common
ground). The protocol is asynchronous in the sense that neither of the shared lines carries a clock
signal. Instead, both parties must agree on how fast data will be sent along the wire <em>before</em> the
communication occurs. This protocol allows <em>duplex</em> communication as data can be sent from A to B
and from B to A simultaneously.</p>
<p>We'll be using this protocol to exchange data between the microcontroller and your computer. Now you
might be asking yourself why exactly we aren't using RTT for this like we did before. RTT is a
protocol that is meant to be used solely for debugging. You will most definitely not be able to find
a device that actually uses RTT to communicate with some other device in production. However, serial
communication is used quite often. For example some GPS receivers send the positioning information
they receive via serial communication. In addition RTT, like many debugging protocols, is slow even
compared to serial transfer rates.</p>
<p>The next practical question you probably want to ask is: How fast can we send data through this
protocol?</p>
<p>This protocol works with frames. Each frame has one <em>start</em> bit, 5 to 9 bits of payload (data) and 1
to 2 <em>stop bits</em>. The speed of the protocol is known as <em>baud rate</em> and it's quoted in bits per
second (bps). Common baud rates are: 9600, 19200, 38400, 57600 and 115200 bps.</p>
<p>To actually answer the question: With a common configuration of 1 start bit, 8 bits of data, 1 stop
bit and a baud rate of 115200 bps one can, in theory, send 11,520 frames per second. Since each one
frame carries a byte of data, that results in a data rate of 11.52 KB/s. In practice, the data rate
will probably be lower because of processing times on the slower side of the communication (the
microcontroller).</p>
<p>Today's computers don't usually support the serial communication protocol, and even if they do the
voltage they use, ±5..12V, may be higher than the micro:bit will accept and may result in damaging
it. You can't directly connect your computer to the microcontroller. You <em>can</em> buy very inexpensive
USB←→serial converters that will support the 0..3V most modern microcontroller boards need. While a
serial converter is not necessary for the MB2, as shown below, it can be handy for inexpensive
boards that have few communications options other than serial.)</p>
<p>The debug probe on the micro:bit itself can act as a USB←→serial converter. This means that the
converter will sit between the two and expose a serial interface to the microcontroller and a USB
interface to your computer. The microcontroller will see your computer as another serial device and
your computer will see the microcontroller as a virtual serial device.</p>
<p>Now, let's get familiar with the serial module and the serial communication tools that your OS
offers. Pick a route:</p>
<ul>
<li><a href="10-serial-communication/nix-tooling.html">Linux/UNIX</a></li>
<li><a href="10-serial-communication/windows-tooling.html">Windows</a></li>
</ul>
<p>For MacOS check out the Linux documentation, although your experience may differ somewhat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-usbserial-tooling"><a class="header" href="#linux-usbserial-tooling">Linux USB←→serial tooling</a></h1>
<p>The micro:bit's USB emulated serial device shows up in Linux when you connect the MB2 to a Linux USB
port.</p>
<h2 id="connecting-the-microbit-board"><a class="header" href="#connecting-the-microbit-board">Connecting the micro:bit board</a></h2>
<p>If you connect the micro:bit board to your computer you should see a new TTY device appear in
<code>/dev</code>.</p>
<pre><code class="language-console">$ sudo dmesg -T | tail | grep -i tty
[63712.446286] cdc_acm 1-1.7:1.1: ttyACM0: USB ACM device
</code></pre>
<p>This is the USB←→serial device. On Linux, it's named <code>tty</code> (for "TeleTYpe", believe it or not).  It
should show up as <code>ttyACM0</code>, or maybe <code>ttyUSB0</code>. If other "ACM" devices are plugged in, the number
will be higher.  (On Mac OS <code>ls /dev/cu.usbmodem*</code> will show the serial device.)</p>
<p>But what exactly is <code>ttyACM0</code>? It's a file of course!  Everything is a file in Unix:</p>
<pre><code>$ ls -l /dev/ttyACM0
crw-rw----+ 1 root plugdev 166, 0 Jan 21 11:56 /dev/ttyACM0
</code></pre>
<p>Note that you will need to be either running as <code>root</code> (not advised) or a member of the group
<code>plugdev</code> to read and write this device. You can then send out data by simply writing to this file:</p>
<pre><code class="language-console">$ echo 'Hello, world!' &gt; /dev/ttyACM0
</code></pre>
<p>You should see the orange LED on the micro:bit, right next to the USB port, blink for a moment,
whenever you enter this command.</p>
<h2 id="minicom"><a class="header" href="#minicom">minicom</a></h2>
<p>We'll use the program <code>minicom</code> to interact with the serial device using the keyboard.</p>
<p>We must configure <code>minicom</code> before we use it. There are quite a few ways to do that but we'll use a
<code>.minirc.dfl</code> file in the home directory. Create a file in <code>~/.minirc.dfl</code> with the following
contents:</p>
<pre><code class="language-console">$ cat ~/.minirc.dfl
pu baudrate 115200
pu bits 8
pu parity N
pu stopbits 1
pu rtscts No
pu xonxoff No
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Make sure this file ends in a newline! Otherwise, <code>minicom</code> will fail to read the last
line.</p>
</blockquote>
<p>That file should be straightforward to read (except for the last two lines), but nonetheless let's
go over it line by line:</p>
<ul>
<li><code>pu baudrate 115200</code>. Sets baud rate to 115200 bps.</li>
<li><code>pu bits 8</code>. 8 bits per frame.</li>
<li><code>pu parity N</code>. No "parity check bit", which would be used for error detection.</li>
<li><code>pu stopbits 1</code>. 1 stop bit.</li>
<li><code>pu rtscts No</code>. No hardware flow control.</li>
<li><code>pu xonxoff No</code>. No software flow control.</li>
</ul>
<p>Once that's in place, we can launch <code>minicom</code> on our ACM device, for example:</p>
<pre><code class="language-console">$ minicom -D /dev/ttyACM0 -b 115200
</code></pre>
<p>This tells <code>minicom</code> to open the serial device at <code>/dev/ttyACM0</code> and set its
baud rate to 115200. A text-based user interface (TUI) will pop out.</p>
<p align="center">
<img title="minicom" src="10-serial-communication/../assets/minicom.png" />
</p>
<p>You can now send data using the keyboard! Go ahead and type something. Note that
the text UI will <em>not</em> echo back what you type. If you pay attention to the yellow LED
on top of the micro:bit though, you will notice that it blinks whenever you type something.</p>
<h2 id="minicom-commands"><a class="header" href="#minicom-commands"><code>minicom</code> commands</a></h2>
<p><code>minicom</code> exposes commands via keyboard shortcuts. On Linux, the shortcuts start with <code>Ctrl+A</code>. (On
Mac, the shortcuts start with the <code>Meta</code> key.) Some useful commands below:</p>
<ul>
<li><code>Ctrl+A</code> + <code>Z</code>. Minicom Command Summary</li>
<li><code>Ctrl+A</code> + <code>C</code>. Clear the screen</li>
<li><code>Ctrl+A</code> + <code>X</code>. Exit and reset</li>
<li><code>Ctrl+A</code> + <code>Q</code>. Quit with no reset</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> Mac users: In the above commands, replace <code>Ctrl+A</code> with <code>Meta</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-tooling"><a class="header" href="#windows-tooling">Windows tooling</a></h1>
<p>Start by unplugging your micro:bit.</p>
<p>Before plugging the micro:bit back in, run the following command on the terminal:</p>
<pre><code class="language-console">$ mode
</code></pre>
<p>It will print a list of devices that are connected to your computer. The ones that start with <code>COM</code>
in their names are serial devices. This is the kind of device we'll be working with. Take note of
all the <code>COM</code> ports' <code>mode</code> outputs <em>before</em> plugging the serial module.</p>
<p>Now, plug in the micro:bit and run the <code>mode</code> command again. If you see a new
<code>COM</code> port appear on the list, then that's the COM port assigned to the
serial functionality on the micro:bit.</p>
<p>Now launch <code>putty</code>. A GUI will pop out.</p>
<p align="center">
<img title="PuTTY settings" src="10-serial-communication/../assets/putty-settings.png" width="500" />
</p>
<p>On the starter screen, which should have the "Session" category open, pick "Serial" as the
"Connection type". On the "Serial line" field enter the <code>COM</code> device you got on the previous step,
for example <code>COM3</code>.</p>
<p>Next, pick the "Connection/Serial" category from the menu on the left. On this new view, make sure
that the serial port is configured as follows:</p>
<ul>
<li>"Speed (baud)": 115200</li>
<li>"Data bits": 8</li>
<li>"Stop bits": 1</li>
<li>"Parity": None</li>
<li>"Flow control": None</li>
</ul>
<p>Finally, click the Open button. A console will show up now:</p>
<p align="center">
<img title="PuTTY console" src="10-serial-communication/../assets/putty-console.png" width="500" />
</p>
<p>If you type on this console, the yellow LED on top of the micro:bit will blink. Each keystroke
should make the LED blink once. Note that the console won't echo back what you type so the screen
will remain blank.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<p>Our microcontroller (like most) has a peripheral called a UART (for "Universal Asynchronous
Receiver/Transmitter). This peripheral can be configured to work with several serial communication
protocols. The peripheral we will be working with is named UARTE (for "UART with Easy DMA", a topic
outside the scope of this chapter).</p>
<p>Throughout this chapter, we'll use serial communication to exchange information between the
microcontroller and your computer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-a-single-byte"><a class="header" href="#send-a-single-byte">Send a single byte</a></h1>
<p>Our first task will be to send a single byte from the microcontroller to the computer over the
serial connection.</p>
<p>In order to do that we will use the following snippet (this one is already in
<code>11-uart/examples/send-byte.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::{
    hal::uarte,
    hal::uarte::{Baudrate, Parity},
};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    serial.write(b'X').unwrap();
    serial.flush().unwrap();

    loop {
        wfi();
    }
}</code></pre></pre>
<p>You might notice that one of the libraries used here, the <code>serial_setup</code> module, is not from
<code>crates.io</code>, but was written for this project. The purpose of <code>serial_setup</code> is to provide a nice
wrapper around the UARTE peripheral. If you want, you can check out what exactly the module does,
but it is not required to understand this chapter in general.</p>
<p>We'll next discuss the initialization of UARTE. The UARTE is initialized with this piece of code:</p>
<pre><code class="language-rs">uarte::Uarte::new(
    board.UARTE0,
    board.uart.into(),
    Parity::EXCLUDED,
    Baudrate::BAUD115200,
);
</code></pre>
<p>This function takes ownership of the UARTE peripheral representation in Rust (<code>board.UARTE0</code>) and
the TX/RX pins on the board (<code>board.uart.into()</code>) so nobody else can mess with either the UARTE
peripheral or our pins while we are using them. After that we pass two configuration options to the
constructor: the baud rate (that one should be familiar) as well as an option called "parity". Parity
is a way to allow serial communication lines to check whether the data they received was corrupted
during transmission. We don't want to use that here so we simply exclude it.  Then we wrap it up in
the <code>UartePort</code> type so we can use it.</p>
<p>After the initialization, we send our <code>X</code> via the newly created uart instance. These serial
functions are "blocking": they wait for the data to be sent before returning. This is not always
what is wanted: the microcontroller can do a lot of work while waiting for the byte to go out on the
wire. However, in our case it is convenient and we didn't have other work to do anyway.</p>
<p>Last but not least, we <code>flush()</code> the serial port. This is because the UARTE may decide to buffer
output until it has received a certain number of bytes to send.  Calling <code>flush()</code> forces it to
write the bytes it currently has right now instead of waiting for more.</p>
<h2 id="testing-it-1"><a class="header" href="#testing-it-1">Testing it</a></h2>
<p>Before flashing this you should make sure to start your minicom/PuTTY as the data we receive via our
serial communication is not backed up or anything: we have to view it live. Once your serial monitor
is up you can flash the program just like in chapter 5:</p>
<pre><code>$ cargo embed --example send-byte
  (...)
</code></pre>
<p>And after the flashing is finished, you should see the character <code>X</code> show up on your minicom/PuTTY
terminal, congrats!</p>
<p>If you missed it, you can hit the reset button on the back of the MB2. This will cause the program
to start from the beginning and send an <code>X</code> again.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-a-string"><a class="header" href="#send-a-string">Send a string</a></h1>
<p>The next task will be to send a whole string from the microcontroller to your computer.</p>
<p>I want you to send the string <code>"The quick brown fox jumps over the lazy dog."</code> from the microcontroller to
your computer.</p>
<p>It's your turn to write the program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naive-approach-and-write"><a class="header" href="#naive-approach-and-write">Naive approach and <code>write!</code></a></h1>
<h2 id="naive-approach"><a class="header" href="#naive-approach">Naive approach</a></h2>
<p>You probably came up with a program similar to the following (<code>examples/naive-send-string.rs</code>):</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    for byte in b"The quick brown fox jumps over the lazy dog.\r\n".iter() {
        serial.write(*byte).unwrap();
    }
    serial.flush().unwrap();

    loop {
        wfi();
    }
}
</code></pre>
<p>While this is a perfectly valid implementation, at some point you might want to have all the nice
perks of <code>print!</code> such as argument formatting and so on. If you are wondering how to do that, read
on.</p>
<h2 id="write-and-corefmtwrite"><a class="header" href="#write-and-corefmtwrite"><code>write!</code> and <code>core::fmt::Write</code></a></h2>
<p>The <code>core::fmt::Write</code> trait allows us to use any struct that implements it in basically the same
way as we use <code>print!</code> in the <code>std</code> world.  In this case, the <code>Uart</code> struct from the <code>nrf</code> HAL does
implement <code>core::fmt::Write</code> so we can refactor our previous program into this
(<code>examples/send-string.rs</code>):</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use core::fmt::Write;
use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    write!(serial, "The quick brown fox jumps over the lazy dog.\r\n").unwrap();
    serial.flush().unwrap();

    loop {
        wfi();
    }
}
</code></pre>
<p>If you flash this program onto your micro:bit, you'll see that it is functionally equivalent to the
iterator-based program you came up with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receive-a-single-byte"><a class="header" href="#receive-a-single-byte">Receive a single byte</a></h1>
<p>So far we can send data from the microcontroller to your computer. It's time to try the opposite:
receiving data from your computer (<code>examples/receive-byte.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    loop {
        let byte = serial.read().unwrap();
        rprintln!("{}", byte);
    }
}</code></pre></pre>
<p>The only part that changed, compared to our send byte program, is the loop at the end of
<code>main()</code>. Here we use the <code>serial.read()</code> function in order to wait until a byte is available and
read it. Then we print that byte into our RTT debugging console to see whether stuff is actually
arriving.</p>
<p>Note that if you flash this program and start typing characters inside <code>minicom</code> to send them to
your microcontroller you'll only be able to see numbers inside your RTT console since we are not
converting the <code>u8</code> we received into an actual <code>char</code>.  Since the conversion from <code>u8</code> to <code>char</code> is
quite simple, I'll leave this task to you if you really do want to see the characters inside the RTT
console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="echo-server"><a class="header" href="#echo-server">Echo server</a></h1>
<p>Let's merge transmission and reception into a single program and write an echo server. An echo
server sends back to the client the same text it receives. For this application, the microcontroller
will be the server and you and your computer will be the client.</p>
<p>This should be straightforward to implement. (hint: do it byte by byte)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-a-string"><a class="header" href="#reverse-a-string">Reverse a string</a></h1>
<p>Alright, next let's make the server more interesting by having it respond to the client with the
reverse of the text that they sent. The server will respond to the client every time they press the
ENTER key. Each server response will be in a new line.</p>
<p>This time you'll need a buffer; you can use <a href="https://docs.rs/heapless/latest/heapless/struct.Vec.html"><code>heapless::Vec</code></a>. Here's the starter code:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use core::fmt::Write;
use heapless::Vec;
use rtt_target::rtt_init_print;
use panic_rtt_target as _;

use microbit::{
    hal::prelude::*,
    hal::uarte,
    hal::uarte::{Baudrate, Parity},
};

mod serial_setup;
use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();

    loop {
        buffer.clear();

        // TODO Receive a user request. Each user request ends with ENTER
        // NOTE `buffer.push` returns a `Result`. Handle the error by responding
        // with an error message.

        // TODO Send back the reversed string
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-2"><a class="header" href="#my-solution-2">My solution</a></h1>
<p>You will find my solution in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::fmt::Write;
use cortex_m_rt::entry;
use heapless::Vec;
use microbit::hal::uarte::{self, Baudrate, Parity};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;
use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();

    loop {
        buffer.clear();

        loop {
            // We assume that the receiving cannot fail
            let byte = serial.read().unwrap();

            if buffer.push(byte).is_err() {
                write!(serial, "error: buffer full\r\n").unwrap();
                break;
            }

            if byte == b'\r' {
                for byte in buffer.iter().rev().chain(&amp;[b'\n', b'\r']) {
                    serial.write(*byte).unwrap();
                }
                break;
            }
        }
        serial.flush().unwrap()
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i2c"><a class="header" href="#i2c">I2C</a></h1>
<p>We just saw the UART serial communication format. UART serial is widely used because it is simple
and has been around almost forever. (Remember how the host device is called a "tty" for "TeleTYpe"?
Yeah, that.) This ubiquity and simplicity makes it a popular choice for simple communications.</p>
<p>Because of hardware limitations on line length <em>vs</em> signal quality and because of difficulty of
accurate decoding, UART serial typically caps out at about 115200 baud under ideal conditions. A
UART serial port has both low bandwidth (11.5KB/s) and high latency (87µs/byte).</p>
<p>UART serial is point-to-point: there is no way to connect three or more devices to the same wire,
and each wire requires a dedicated hardware device on each end.</p>
<p>The good news (and the bad news) is that there are <em>plenty</em> of other hardware-assisted serial
communication protocols in the embedded space that overcome these limitations. Some of them are
widely used in digital sensors.</p>
<p>The micro:bit board we are using has two motion sensors in it: an accelerometer and a magnetometer.
Both of these sensors are packaged into a single component and can be accessed via an I2C bus.</p>
<p>I2C is pronounced "EYE-SQUARED-CEE" and stands for Inter-Integrated Circuit. I2C is a <em>synchronous</em>
serial <em>bus</em> communication protocol: it uses two lines to exchange data: a data line (SDA) and a
clock line (SCL). The clock line is used to synchronize the communication. Synchronous serial can
run faster and more reliably than async serial. I2C devices have <em>bus addresses</em>: the hardware
implementation allows sending bytes to a particular device, with other devices connected to the same
wires ignoring this communication.</p>
<p align="center">
<img class="white_bg" height="360" title="I2C bus" src="12-i2c/../assets/i2c-bus.svg" />
</p>
<p>I2C uses a <em>controller</em>/<em>target</em> model: the controller is the device that <em>starts</em> and drives the
communication with a target device. Several devices can be connected to the same bus at the same
time, and can choose to act either as a controller or as a target. A controller device can
communicate with a specific target device by first broadcasting the target address to the bus. This
address can be 7 bits or 10 bits long.  Once a controller has started a communication with a target,
no device is other than the controller and target is allowed to transmit on the bus until the
controller ends the communication.</p>
<blockquote>
<p><strong>NOTE</strong> "Controller/target" was formerly referred to as "master/slave". You may still see that in
literature or as labeling on boards. This terminology is now deprecated both in official standards
and newer documents, but is used in the Nordic manual for our nRF52833 part and in some embedded
Rust documentation.</p>
</blockquote>
<p>The clock line determines how fast data can be exchanged. The MB2 I2C interface can operate at
speeds of 100, 250 or 400 Kbps. With other devices even faster modes are possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-protocol"><a class="header" href="#general-protocol">General protocol</a></h1>
<p>The I2C protocol is more elaborate than the serial communication protocol because it has to support
communication between several devices. Let's see how it works using examples:</p>
<h2 id="controller--target"><a class="header" href="#controller--target">Controller → Target</a></h2>
<p>If the Controller wants to send data to the Target:</p>
<p align="center">
  <img class="white_bg" height="360" title="I2C bus" src="12-i2c/../assets/i2c-controller-target.svg" />
</p>
<ol>
<li>Controller: Broadcast START</li>
<li>C: Broadcast target address (7 bits) + the R/W (8th) bit set to WRITE</li>
<li>Target: Responds ACK (ACKnowledgement)</li>
<li>C: Send one byte</li>
<li>T: Responds ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>C: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The target address could have been 10 bits instead of 7 bits long. Nothing else would have
changed.</p>
</blockquote>
<h2 id="controller--target-1"><a class="header" href="#controller--target-1">Controller ← Target</a></h2>
<p>If the controller wants to read data from the target:</p>
<p align="center">
  <img class="white_bg" height="360" title="I2C bus" src="12-i2c/../assets/i2c-controller-target.svg" />
</p>
<ol>
<li>C: Broadcast START</li>
<li>C: Broadcast target address (7 bits) + the R/W (8th) bit set to READ</li>
<li>T: Responds with ACK</li>
<li>T: Send byte</li>
<li>C: Responds with ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>C: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The target address could have been 10 bits instead of 7 bits long. Nothing else would
have changed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsm303agr"><a class="header" href="#lsm303agr">LSM303AGR</a></h1>
<p>Both of the motion sensors on the micro:bit, the magnetometer and the accelerometer, are packaged in
a single component: the LSM303AGR integrated circuit. These two sensors can be accessed via an I2C
bus. Each sensor behaves like an I2C target and has a <em>different</em> address.</p>
<p>Each sensor has its own memory where it stores the results of sensing its environment. Our
interaction with these sensors will mainly involve reading their memory.</p>
<p>The memory of these sensors is modeled as byte addressable registers. These sensors can be
configured too; that's done by writing to their registers. So, in a sense, these sensors are very
similar to the peripherals <em>inside</em> the microcontroller. The difference is that their registers are
not mapped into the microcontrollers' memory. Instead, their registers have to be accessed via the
I2C bus.</p>
<p>The main source of information about the LSM303AGR is its <a href="https://www.st.com/resource/en/datasheet/lsm303agr.pdf">Data Sheet</a>. Read through it to see how
one can read the sensors' registers. That part is in:</p>
<blockquote>
<p>Section 6.1.1 I2C Operation - Page 38 - LSM303AGR Data Sheet</p>
</blockquote>
<p>The other part of the documentation relevant to this book is the description of the registers. That
part is in:</p>
<blockquote>
<p>Section 8 Register description - Page 46 - LSM303AGR Data Sheet</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-a-single-register"><a class="header" href="#read-a-single-register">Read a single register</a></h1>
<p>Let's put all that theory into practice!</p>
<p>First things first we need to know the target addresses of both the accelerometer and the
magnetometer inside the chip, these can be found in the LSM303AGR's datasheet on page 39 and are:</p>
<ul>
<li>0011001 for the accelerometer</li>
<li>0011110 for the magnetometer</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> Remember that these are only the 7 leading bits of the address, the 8th bit is going to
be the bit that determines whether we are performing a read or write.</p>
</blockquote>
<p>Next up we'll need a register to read from. Lots of I2C chips out there will provide some sort of
device identification register for their controllers to read. Considering the thousands (or even
millions) of I2C chips out there it is highly likely that at some point two chips with the same
address will end up being built (after all the address is "only" 7 bit wide). With this device ID
register a driver can make sure that it is indeed talking to a LSM303AGR and not some other chip
that just happens to have the same address.  As you can read in the LSM303AGR's datasheet
(specifically on page 46 and 61) this part does provide two registers — <code>WHO_AM_I_A</code> at address
<code>0x0f</code> and <code>WHO_AM_I_M</code> at address <code>0x4f</code> — which contain some bit patterns that are unique to the
device. (The "A" is for "Accelerometer" and the "M" is for "Magnetometer".)</p>
<p>The only thing missing now is the software part: we need to determine which API of the <code>microbit</code> or
a HAL crate we should use for this. If you read through the datasheet of the nRF chip you are using
you will soon find out that it doesn't actually have an I2C-specific peripheral.  Instead, it has
more general-purpose I2C-compatible peripherals called TWI ("Two-Wire Interface"), TWIM ("Two-Wire
Interface Master") and TWIS ("Two-Wire Interface Slave"). We will normally be operating in
controller mode and will use the newer TWIM, which supports "Easy DMA" — the TWI is provided mostly
for backward compatibility with older devices.</p>
<p>Now if we put the documentation of the <a href="https://docs.rs/microbit-v2/0.11.0/microbit/hal/twim/index.html"><code>twi(m)</code> module</a> from the <code>microbit</code> crate
together with all the other information we have gathered so far we'll end up with this
piece of code to read out and print the two device IDs (<code>examples/chip-id.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use embedded_hal::i2c::I2c;
use microbit::{hal::twim, pac::twim0::frequency::FREQUENCY_A};

const ACCELEROMETER_ADDR: u8 = 0b0011001;
const MAGNETOMETER_ADDR: u8 = 0b0011110;

const ACCELEROMETER_ID_REG: u8 = 0x0f;
const MAGNETOMETER_ID_REG: u8 = 0x4f;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut acc = [0u8];
    let mut mag = [0u8];

    // First write the address + register onto the bus, then read the chip's responses
    i2c.write_read(ACCELEROMETER_ADDR, &amp;[ACCELEROMETER_ID_REG], &amp;mut acc)
        .unwrap();
    i2c.write_read(MAGNETOMETER_ADDR, &amp;[MAGNETOMETER_ID_REG], &amp;mut mag)
        .unwrap();

    rprintln!("The accelerometer chip's id is: {:#b}", acc[0]);
    rprintln!("The magnetometer chip's id is: {:#b}", mag[0]);

    loop {
        wfi();
    }
}</code></pre></pre>
<p>Apart from the initialization, this piece of code should be straight forward if you understood the
I2C protocol as described before. The initialization here works similarly to the one from the UART
chapter.  We pass the peripheral as well as the pins that are used to communicate with the chip to
the constructor; and then the frequency we wish the bus to operate on, in this case 100 kHz (<code>K100</code>,
since identifiers can't start with a digit).</p>
<h2 id="testing-it-2"><a class="header" href="#testing-it-2">Testing it</a></h2>
<p>As usual</p>
<pre><code class="language-console">$ cargo embed --example chip-id
</code></pre>
<p>in order to test our little example program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-driver"><a class="header" href="#using-a-driver">Using a driver</a></h1>
<p>As we already discussed in chapter 5 <code>embedded-hal</code> provides abstractions
which can be used to write platform independent code that can interact with
hardware. In fact all the methods we have used to interact with hardware
in chapter 7 and up until now in chapter 8 were from traits, defined by <code>embedded-hal</code>.
Now we'll make actual use of the traits <code>embedded-hal</code> provides for the first time.</p>
<p>It would be pointless to implement a driver for our LSM303AGR for every platform
embedded Rust supports (and new ones that might eventually pop up). To avoid this a driver
can be written that consumes generic types that implement <code>embedded-hal</code> traits in order to provide
a platform agnostic version of a driver. Luckily for us this has already been done in the
<a href="https://crates.io/crates/lsm303agr"><code>lsm303agr</code></a> crate. Hence reading the actual accelerometer and magnetometer values will now
be basically a plug and play experience (plus reading a bit of documentation). In fact the <code>crates.io</code>
page already provides us with everything we need to know in order to read accelerometer data but using a Raspberry Pi. We'll
just have to adapt it to our chip:</p>
<p>Take a look at the linked page for the Raspberry Pi Linux sample code.</p>
<p>Because we already know how to create an instance of an object that implements the
<a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/blocking/i2c/index.html"><code>embedded_hal::blocking::i2c</code></a> traits from the <a href="12-i2c/read-a-single-register.html">previous page</a>, adapting
the sample code is straightforward (<code>examples/show-accel.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{AccelMode, AccelOutputDataRate, Lsm303agr};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };
    let mut timer0 = Timer::new(board.TIMER0);

    // Code from documentation
    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(
            &amp;mut timer0,
            AccelMode::HighResolution,
            AccelOutputDataRate::Hz50,
        )
        .unwrap();
    loop {
        if sensor.accel_status().unwrap().xyz_new_data() {
            let (x, y, z) = sensor.acceleration().unwrap().xyz_mg();
            // RTT instead of normal print
            rprintln!("Acceleration: x {} y {} z {}", x, y, z);
        }
    }
}</code></pre></pre>
<p>Just like the last snippet you should just be able to try this out like this:</p>
<pre><code class="language-console">$ cargo embed --example show-accel
</code></pre>
<p>Furthermore if you (physically) move around your micro:bit a little you should see the
acceleration numbers that are being printed change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-2"><a class="header" href="#the-challenge-2">The challenge</a></h1>
<p>The challenge for this chapter is to build a small application that communicates with the outside
world via the serial interface introduced in the last chapter. It should expect to receive the
commands "mag" for magnetometer as well as "acc" for accelerometer from the serial port. It should
then be able to send the corresponding sensor data to the serial port in response.</p>
<p>This time no template code will be provided since all you need is already provided in the
<a href="12-i2c/../11-uart/index.html">UART</a> and this chapter. However, here are a few clues:</p>
<ul>
<li>
<p>You might be interested in <code>core::str::from_utf8</code> to convert the bytes in the buffer to a <code>&amp;str</code>, since we need to compare with <code>"mag"</code> and <code>"acc"</code>.</p>
</li>
<li>
<p>You will have to read the documentation for the magnetometer API and functionality. While the <code>lsm303agr</code> crate provides the API interface, the <a href="https://www.st.com/resource/en/datasheet/lsm303agr.pdf">LSM303AGR datasheet</a> details the sensor's magnetic field measurement parameters. See pages 13-15 for sensor characteristics and, importantly, pages 66-67 for the output register format.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-3"><a class="header" href="#my-solution-3">My solution</a></h1>
<p>My solution is in <code>src/main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::str;

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::{rtt_init_print, rprintln};

use microbit::{
    hal::uarte::{self, Baudrate, Parity},
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use core::fmt::Write;
use heapless::Vec;
use lsm303agr::{AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let serial = uarte::Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );
    let mut serial = UartePort::new(serial);

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };
    let mut timer0 = Timer::new(board.TIMER0);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(
            &amp;mut timer0,
            AccelMode::HighResolution,
            AccelOutputDataRate::Hz50,
        )
        .unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz50,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();
    rprintln!("setup complete");

    loop {
        buffer.clear();

        loop {
            let byte = serial.read().unwrap();
            serial.write(byte).unwrap();

            if byte == b'\r' {
                serial.write(b'\n').unwrap();
                break;
            }

            if buffer.push(byte).is_err() {
                write!(serial, "error: buffer full\r\n").unwrap();
                break;
            }
        }

        if str::from_utf8(&amp;buffer).unwrap().trim() == "acc" {
            while !sensor.accel_status().unwrap().xyz_new_data() {
                timer0.delay_ms(1u32);
            }

            let (x, y, z) = sensor.acceleration().unwrap().xyz_mg();
            write!(serial, "Accelerometer: x {} y {} z {}\r\n", x, y, z).unwrap();
        } else if str::from_utf8(&amp;buffer).unwrap().trim() == "mag" {
            while !sensor.mag_status().unwrap().xyz_new_data() {
                timer0.delay_ms(1u32);
            }

            let (x, y, z) = sensor.magnetic_field().unwrap().xyz_nt();
            write!(serial, "Magnetometer: x {} y {} z {}\r\n", x, y, z).unwrap();
        } else {
            write!(serial, "error: command not detected\r\n").unwrap();
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="led-compass"><a class="header" href="#led-compass">LED compass</a></h1>
<p>In this section, we'll implement a compass using the LEDs on the micro:bit. Like proper compasses,
our LED compass must point north somehow. It will do that by turning on one of its outer LEDs; the
LED turned on should point towards north.</p>
<p>Magnetic fields have both a magnitude, measured in Gauss or Teslas, and a <em>direction</em>. The
magnetometer on the micro:bit measures both the magnitude and the direction of an external magnetic
field, but it reports back the <em>decomposition</em> of said field along <em>its axes</em>.</p>
<p>The magnetometer has three axes associated with it. When the board is held flat with the LEDs facing
uupward and the logo facing forward, the X and Y axes span the plane that is the floor. The X axis
points to the left edge of the board. The Y axis points to the bottom (card connector) edge of the
board.  The Z axis points "into the floor", so downwards: "upside down" since the chip is mounted on
the back. This is a "right-handed" coordinate system. It's all a bit confusing, since the reported
field strengths are components of the magnetic field vector.</p>
<p align="center">
<img title="MB2 Axes" src="13-led-compass/../assets/mb2-axes.jpg" width="500" />
</p>
<p>You should already be able to write a program that continuously prints the magnetometer data on the
RTT console from the <a href="13-led-compass/../12-i2c/index.html">I2C chapter</a>. After you write that program
(<code>examples/show-mag.rs</code>), locate where north is at your current location. Then line up your
micro:bit with that direction and observe how the sensor's X and Y measurements look.</p>
<p>Now rotate the board 90 degrees while keeping it parallel to the ground. What X, Y and Z values do
you see this time? Then rotate it 90 degrees again. What values do you see?</p>
<blockquote>
<p><strong>NOTE</strong> Of the two MB2s I have handy at the time of this writing, one of them seems to have a
somewhat broken magnetometer: the Z-axis is unusably offset. The manufacturer has a self-test
process for detecting this and a calibration process for mitigating this kind of "hard iron"
fault, which is usually the result of exposing the MB2 to a strong magnetic field at some
point. However, the <code>lsm303agr</code> crate currently doesn't support either of these, and it seems like
a lot for an introductory guide to embedded systems. If you have only one MB2 and it doesn't seem
to be working, you may just want to skip to the <a href="13-led-compass/../14-punch-o-meter/index.html">next chapter</a>. Cheap hardware: whatcha gonna do?</p>
</blockquote>
<p>The Earth's magnetic north is a fickle thing: it differs from true north in most places on Earth,
sometimes substantially. It can point down into the ground quite a bit. It changes over time.
Without allowing for all this, you won't get a very accurate compass even if your MB2 magnetometer
is perfect (it's not). This US NOAA calculator
<a href="https://www.ngdc.noaa.gov/geomag/calculators/mobileDeclination.shtml">https://www.ngdc.noaa.gov/geomag/calculators/mobileDeclination.shtml</a> can be visited on your mobile
device to get a good estimate of true north as well as magnetic north; you can give this UK BGS
<a href="http://www.geomag.bgs.ac.uk/data_service/models_compass/wmm_calc.html">calculator</a> your latitude, longitude and altitude to get both declination and inclination.  At my
location the "declination" (difference between true and magnetic north) is about 15°; the
"inclination" is an astonishing 67° down into the ground.</p>
<blockquote>
<p><strong>NOTE</strong> The LSM303AGR magnetometer is not a particularly accurate device out-of-the box. The
manufacturer recommends a fancy calibration procedure for finding adjustments to the magnetometer
readings. You can find further information, a sample calibration implementation and some fancier
compass graphics in <a href="13-led-compass/../appendix/3-mag-calibration/index.html">appendix 3</a>: since we're doing something fairly basic with the magnetometer
we won't worry about it in this chapter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magnitude"><a class="header" href="#magnitude">Magnitude</a></h1>
<p>How strong is the Earth's magnetic field?  According to the documentation about the
<a href="https://docs.rs/lsm303agr/1.1.0/lsm303agr/struct.Lsm303agr.html#method.magnetic_field"><code>magnetic_field()</code></a> method the <code>x</code> <code>y</code> <code>z</code> values we are getting are in nanoteslas. That means the
only thing we have to compute in order to get the magnitude of the magnetic field in nanoteslas is
the magnitude of the 3D vector that our <code>x</code> <code>y</code> <code>z</code> values describe. As you might remember from
school this is simply:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libm::sqrtf;
let magnitude = sqrtf(x * x + y * y + z * z);
<span class="boring">}</span></code></pre></pre>
<p>Rust does not have floating-point math functions such as <code>sqrtf()</code> in <code>core</code>, so our <code>no_std</code>
program has to get an implementation from somewhere. We use the <a href="https://crates.io/crates/libm">libm</a> crate for this.</p>
<p>Putting all this together in a program (<code>examples/magnitude.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use libm::sqrtf;

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz10,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    loop {
        while !sensor.mag_status().unwrap().xyz_new_data() {
            timer0.delay_ms(1u32);
        }
        let (x, y, z) = sensor.magnetic_field().unwrap().xyz_nt();
        let (x, y, z) = (x as f32, y as f32, z as f32);
        let magnitude = sqrtf(x * x + y * y + z * z);
        rprintln!("{} mG", magnitude / 100.0);
    }
}</code></pre></pre>
<p>Run this with <code>cargo run --example magnitude</code>.</p>
<p>This program will report the magnitude (strength) of the magnetic field in nanotesla (<code>nT</code>) and
milligauss (<code>mG</code>, where 1 <code>mG</code> = 100 <code>nT</code>). The magnitude of the Earth's magnetic field is in the
range of <code>250 mG</code> to <code>650 mG</code> (the magnitude varies depending on your geographical location) so you
ideally would see a value vaguely in that range. Your value will likely be off quite a bit because
the sensor has not been calibrated: see <a href="13-led-compass/../appendix/3-mag-calibration/index.html">appendix 3</a> for calibration. With calibration, I see a
magnitude of around <code>340 mG</code>.</p>
<p>Some questions:</p>
<ul>
<li>
<p>Without moving the board, what value do you see? Do you always see the same value?</p>
</li>
<li>
<p>If you rotate the board, does the magnitude change? Should it change?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-3"><a class="header" href="#the-challenge-3">The Challenge</a></h1>
<p>We'll use some fancy math to get the precise angle that the magnetic field forms with the X and Y
axes of the magnetometer. This will allow us to figure out which LED is pointing north.</p>
<p>We'll use the <code>atan2</code> function. This function returns an angle in the <code>-PI</code> to <code>PI</code> range. The
graphic below shows how this angle is measured:</p>
<p align="center">
<img class="white_bg" title="atan2" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Atan2_60.svg" />
</p>
<p>Although not explicitly shown, in this graph the X axis points to the right and the Y axis points
up. Note that our coordinate system is rotated 180° from this.</p>
<p>Here's the starter code (in <code>templates/compass.rs</code>). <code>theta</code>, in radians, has already been
computed. You need to pick which LED to turn on based on the value of <code>theta</code>.</p>
<pre><code class="language-rs">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

// You'll find these useful ;-).
use core::f32::consts::PI;
use libm::{atan2f, floorf};

use microbit::{
    display::blocking::Display,
    hal::{Timer, twim},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor.set_mag_mode_and_odr(
        &amp;mut timer0,
        MagMode::HighResolution,
        MagOutputDataRate::Hz10,
    ).unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    let mut leds = [[0u8; 5]; 5];

    // Indexes of the 16 LEDs to be used in the display, and their
    // compass directions.
    #[rustfmt::skip]
    let indices = [
        (2, 0) /* W */, (3, 0) /* W-SW */, (3, 1) /* SW */, (4, 1) /* S-SW */,
        (4, 2) /* S */, (4, 3) /* S-SE */, (3, 3) /* SE */, (3, 4) /* E-SE */,
        (2, 4) /* E */, (1, 4) /* E-NE */, (1, 3) /* NE */, (0, 3) /* N-NE */,
        (0, 2) /* N */, (0, 1) /* N-NW */, (1, 1) /* NW */, (1, 0) /* W-NW */,
    ];

    loop {
        // Measure the magnetic field.
        let (x, y) = todo!();

        // Get an angle between -180° and 180° from the x axis.
        let theta = atan2f(y as f32, x as f32);

        // Figure out what LED index to blink.
        let index = todo!();

        // Blink the given LED.
        let (r, c) = indices[index];
        leds[r][c] = 255u8;
        display.show(&amp;mut timer0, leds, 50);
        leds[r][c] = 0u8;
        display.show(&amp;mut timer0, leds, 50);
    }
}
</code></pre>
<p>Suggestions/tips:</p>
<ul>
<li>A whole circle rotation equals 360 degrees.</li>
<li><code>PI</code> radians is equivalent to 180 degrees.</li>
<li>If <code>theta</code> is zero, which direction are you pointing at?</li>
<li>If <code>theta</code> is instead very close to zero, which direction are you pointing at?</li>
<li>If <code>theta</code> keeps increasing, at what value should you change the direction</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-4"><a class="header" href="#my-solution-4">My Solution</a></h1>
<p>Here's my solution (in <code>src/main.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

// You'll find these useful ;-).
use core::f32::consts::PI;
use libm::{atan2f, floorf};

use microbit::{
    display::blocking::Display,
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz10,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    let mut leds = [[0u8; 5]; 5];

    // Indexes of the 16 LEDs to be used in the display, and their
    // compass directions.
    #[rustfmt::skip]
    let indices = [
        (2, 0), /* W */
        (3, 0), /* W-SW */
        (3, 1), /* SW */
        (4, 1), /* S-SW */
        (4, 2), /* S */
        (4, 3), /* S-SE */
        (3, 3), /* SE */
        (3, 4), /* E-SE */
        (2, 4), /* E */
        (1, 4), /* E-NE */
        (1, 3), /* NE */
        (0, 3), /* N-NE */
        (0, 2), /* N */
        (0, 1), /* N-NW */
        (1, 1), /* NW */
        (1, 0), /* W-NW */
    ];

    loop {
        while !sensor.mag_status().unwrap().xyz_new_data() {
            timer0.delay_ms(1u32);
        }
        let (x, y, _) = sensor.magnetic_field().unwrap().xyz_nt();

        // Get an angle between -180° and 180° from the x axis.
        let theta = atan2f(y as f32, x as f32);

        // Cut the unit circle into thirty-two segments,
        // with pairs of adjacent segments corresponding to
        // each compass direction.
        let seg = floorf(16.0 * theta / PI) as i8;

        // Figure out what LED index to blink.
        let index = if seg &gt;= 15 || seg &lt;= -15 {
            8
        } else if seg &gt;= 0 {
            (seg / 2) as usize
        } else {
            ((31 + seg) / 2) as usize
        };

        // Blink the given LED.
        let (r, c) = indices[index];
        leds[r][c] = 255u8;
        display.show(&amp;mut timer0, leds, 50);
        leds[r][c] = 0u8;
        display.show(&amp;mut timer0, leds, 50);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punch-o-meter"><a class="header" href="#punch-o-meter">Punch-o-meter</a></h1>
<p>In this section we'll be playing with the accelerometer that's in the board.</p>
<p>What are we building this time? A punch-o-meter! We'll be measuring the power of your jabs. Well,
actually the maximum acceleration that you can reach because acceleration is what accelerometers
measure. Strength and acceleration are proportional though so it's a good approximation.</p>
<p>As we already know from previous chapters the accelerometer is built inside the LSM303AGR package.
And just like the magnetometer, it is accessible using the
I2C bus.</p>
<p>The accelerometer also has the same coordinate system as the magnetometer. Here's a reminder:</p>
<p align="center">
<img title="MB2 Axes" src="14-punch-o-meter/../assets/mb2-axes.jpg" width="500" />
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gravity-is-up"><a class="header" href="#gravity-is-up">Gravity is up?</a></h1>
<p>What's the first thing we'll do?</p>
<p>Perform a sanity check!</p>
<p>You should already be able to write a program that continuously prints the accelerometer data on the
RTT console from the <a href="14-punch-o-meter/../12-i2c/index.html">I2C chapter</a>. Mine is in <code>examples/show-accel.rs</code>. Do you
observe something interesting even when holding the board parallel to the floor with the back side
facing up?  (Remember that the accelerometer is mounted on the back of the board, so holding it
upside-down like this makes the Z axis point up.)</p>
<p>What you should see when holding the board like this is that both the X and Y values are rather
close to 0, while the Z value is at around 1000. Which is weird: the board is not moving, yet its
acceleration is non-zero. What's going on? This must be related to the gravity, right? Because the
acceleration of gravity is <code>1 g</code> (aha, <code>1 g</code> = -1000 from the accelerometer). But the gravity pulls
objects downwards so the acceleration along the Z axis should be positive, not negative.</p>
<p>Did the program get the Z axis backwards? Nope, you can test rotating the board to align the gravity
to the X or Y axis but the acceleration measured by the accelerometer is always pointing up.</p>
<p>What happens here is that the accelerometer is measuring the <em>proper acceleration</em> of the board, not
the acceleration <em>you</em> are observing. This proper acceleration is the acceleration of the board as
seen from an observer that's in free fall. An observer that's in free fall is moving toward the
center of the Earth with an acceleration of <code>1g</code>; from its point of view the board is actually
moving upwards (away from the center of the Earth) with an acceleration of <code>1g</code>. And that's why the
proper acceleration is pointing up. This also means that if the board was in free fall, the
accelerometer would report a proper acceleration of zero. Please, don't try that at home. Or do, if
you're willing to risk your MB2 by dropping it.</p>
<p>Yes, physics is hard. Let's move on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-4"><a class="header" href="#the-challenge-4">The challenge</a></h1>
<p>To keep things simple, we'll measure the acceleration only in the X axis while the board remains
horizontal. That way we won't have to deal with subtracting that <em>fictitious</em> <code>1g</code> we observed
before which would be hard because that <code>1g</code> could have X Y Z components depending on how the board
is oriented.</p>
<p>Here's what the punch-o-meter must do:</p>
<ul>
<li>By default, the app is not "observing" the acceleration of the board.</li>
<li>When a significant X acceleration is detected (i.e. the acceleration goes above some threshold),
the app should start a new measurement.</li>
<li>During that measurement interval, the app should keep track of the maximum acceleration observed</li>
<li>After the measurement interval ends, the app must report the maximum acceleration observed. You
can report the value using the <code>rprintln!</code> macro.</li>
</ul>
<p>Give it a try and let me know how hard you can punch <code>;-)</code>.</p>
<blockquote>
<p><strong>NOTE</strong> There is an additional API that should be useful for this task that we haven't
discussed yet: the <a href="https://docs.rs/lsm303agr/1.1.0/lsm303agr/struct.Lsm303agr.html#method.set_accel_scale"><code>set_accel_scale</code></a> one which you need to measure high g values.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-5"><a class="header" href="#my-solution-5">My solution</a></h1>
<p>Here's my solution (<code>src/main.rs</code>). Note that you can get quite high G values by rapping the edge of
your MB2 on a table. Note also that this can break the accelerometer, so probably don't?</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

const TICKS_PER_SEC: u32 = 400;
const THRESHOLD: f32 = 1.5;

use cortex_m::asm::nop;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{AccelMode, AccelOutputDataRate, AccelScale, Lsm303agr};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut delay = Timer::new(board.TIMER0);
    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(&amp;mut delay, AccelMode::Normal, AccelOutputDataRate::Hz400)
        .unwrap();
    // Allow the sensor to measure up to 16 G since human punches
    // can actually be quite fast
    sensor.set_accel_scale(AccelScale::G16).unwrap();

    let mut max_g = 0.;
    let mut countdown_ticks = None;

    loop {
        while !sensor.accel_status().unwrap().xyz_new_data() {
            nop();
        }
        // x acceleration in g
        let (x, _, _) = sensor.acceleration().unwrap().xyz_mg();
        let g_x = x as f32 / 1000.0;

        if let Some(ticks) = countdown_ticks {
            if ticks &gt; 0 {
                // countdown isn't done yet
                if g_x &gt; max_g {
                    max_g = g_x;
                }
                countdown_ticks = Some(ticks - 1);
            } else {
                // Countdown is done: report max value
                rprintln!("Max acceleration: {}g", max_g);

                // Reset
                max_g = 0.;
                countdown_ticks = None;
            }
        } else {
            // If acceleration goes above a threshold, we start measuring
            if g_x &gt; THRESHOLD {
                rprintln!("START!");

                max_g = g_x;
                countdown_ticks = Some(TICKS_PER_SEC);
            }
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h2>
<p>So far, we've touched a bunch of hardware on the MB2. We've read out buttons, waited for timers, done serial communication, and talked to devices using I2C.  Each of these things involved waiting for one or more peripherals to become ready. So far, our waiting was by "polling": repeatedly asking the peripheral if it's done yet, until it is.</p>
<p>Seeing as our microcontroller only has a single CPU core, it cannot do anything else while it waits. On top of that, a CPU core continuously polling a peripheral wastes power, and in a lot of applications, we can't have that. Can we do better?</p>
<p>Luckily, we can! While our little microcontroller can't compute things in parallel, it can easily switch between different tasks during execution, responding to events from the outside world. This switching is done using a feature called "interrupts".</p>
<p>Interrupts are aptly named: they allow peripherals to actually interrupt the core program execution at any point in time. On our MB2's nRF52833, peripherals are connected to the core's Nested Vectored Interrupt Controller (NVIC). The NVIC can stop the CPU in its tracks, instruct it to go do something else, and once that's done, get the CPU back to what it was doing before it was interrupted. We'll cover the Nested and Vectored parts of the interrupt controller later: let's first focus on how the core switches tasks.</p>
<h3 id="handling-interrupts"><a class="header" href="#handling-interrupts">Handling Interrupts</a></h3>
<p>The model of computation used by our NRF52833 is the one used by almost every modern CPU. Inside the CPU are "scratch-pad" storage locations known as "CPU registers". (Confusingly, these CPU registers are different from the "device registers" we discussed earlier in the <a href="15-interrupts/../09-registers/index.html">Registers</a> chapter.)  To carry out a computation, the CPU typically loads values from memory to CPU registers, performs the computation using the register values, then stores the result back to memory.  (This is known as a "load-store architecture".)</p>
<p>Everything about the computation the CPU is currently running is stored in the CPU registers. If the core is going to switch tasks, it must store the contents of the CPU registers somewhere so that the new task can use the registers as its own scratch-pad. When the new task is complete the CPU can then restore the register values and restart the old computation.  Sure enough, that is exactly the first thing the core does in response to an interrupt request: it stops what it's doing immediately and stores the contents of the CPU registers on the stack.</p>
<p>The next step is actually jumping to the code that should be run in response to an interrupt.  An Interrupt Service Routines (ISR), often referred to as an interrupt "handler", is a special function in your application code that gets called by the core in response to interrupts. An "interrupt table" in memory contains an "interrupt vector" for every possible interrupt: the interrupt vector indicates what ISR to call when a specific interrupt is received. We describe the details of ISR vectoring in the <a href="15-interrupts/nvic-and-interrupt-priority.html">NVIC and Interrupt Priority</a> section.</p>
<p>An ISR function "returns" using a special return-from-interrupt machine instruction that causes the CPU to restore the CPU registers and jump back to where it was before the ISR was called.</p>
<h2 id="poke-the-mb2"><a class="header" href="#poke-the-mb2">Poke The MB2</a></h2>
<p>Let's define an ISR and configure an interrupt to "poke" the MB2 when Button A is pressed
(<code>examples/poke.rs</code>). The board will respond by saying "ouch" and panicking.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    Board,
    hal::{
        gpiote,
        pac::{self, interrupt},
    },
};

/// This "function" will be called when an interrupt is received. For now, just
/// report and panic.
#[interrupt]
fn GPIOTE() {
    rprintln!("ouch");
    panic!();
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let button_a = board.buttons.button_a.into_floating_input();

    // Set up the GPIOTE to generate an interrupt when Button A is pressed (GPIO
    // wire goes low).
    let gpiote = gpiote::Gpiote::new(board.GPIOTE);
    let channel = gpiote.channel0();
    channel
        .input_pin(&amp;button_a.degrade())
        .hi_to_lo()
        .enable_interrupt();
    channel.reset_events();

    // Set up the NVIC to handle GPIO interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::GPIOTE) };
    pac::NVIC::unpend(pac::Interrupt::GPIOTE);

    loop {
        // "wait for interrupt": CPU goes to sleep until an interrupt.
        asm::wfi();
    }
}</code></pre></pre>
<p>The ISR handler function is "special". The name <code>GPIOTE</code> is required here, indicating
that this ISR should be stored at the entry for the <code>GPIOTE</code> interrupt in the interrupt table.</p>
<p>The <code>#[interrupt]</code> decoration is used at compile time to mark a function to be treated specially as
an ISR. (This is a "proc macro", in case you feel like exploring that concept.)</p>
<p>Marking a function with <code>#[interrupt]</code> implies several special things about the function:</p>
<ul>
<li>
<p>The compiler will check that the function takes no arguments and returns no value. The CPU has no
arguments to provide to an ISR, and no place to put a return value from the ISR.</p>
</li>
<li>
<p>The compiler will place a vector to this function at the location in the interrupt table
implied by the function's name.</p>
</li>
<li>
<p>The function will be compiled to finishing by using a return-from-interrupt instruction rather
than the normal function return instruction.</p>
</li>
<li>
<p>Since the function finishes in a non-standard way, the compiler will understand not to allow
directly calling the ISR from normal code.</p>
</li>
</ul>
<p>There are two steps to configure the interrupt. First, the GPIOTE must be set up to generate an
interrupt when the pin connected to Button A goes from high to low voltage. Second, the NVIC must be
configured to allow the interrupt. Order matters a bit: doing things in the "wrong" order may
generate an interrupt before you are ready to handle it.</p>
<p><strong>Note</strong> As with most microcontrollers, there is a lot of flexibility in when the GPIOTE can generate an interrupt. Interrupts can be generated on low-to-high pin transition, high-to-low (as here), any change ("edge"), when low, or when high. On the nRF52833, interrupts generate an event that must be manually cleared in the ISR to ensure that the ISR is not called a second time for the same interrupt. Other microcontrollers may work a little differently — you should read Rust crate and microcontroller documentation to understand the details on a different board.</p>
<p>When you push the A Button, you will see an "ouch" message and then a panic. Why does the interrupt
handler call <code>panic!()</code>? Try commenting the <code>panic!()</code> call out and see what happens when you push
the button. You will see "ouch" messages scroll off the screen. The NVIC records when an interrupt
has been issued: that "event" is kept until it is explicitly cleared by the running program. Without
the <code>panic!()</code>, when the interrupt handler returns the NVIC will (in this case) re-enable the
interrupt, notice that there is still an interrupt event pending, and run the handler again. This
will continue forever: each time the interrupt handler returns it will be called again. As we will
see in a bit, the interrupt indication can be cleared from within the interrupt handler using the
<code>reset_event()</code> peripheral method.</p>
<p>You may define ISRs for many different interrupt sources: when I2C is ready, when a timer expires,
and on and on. Inside an ISR you can do pretty much anything you want, but it's good practice to
keep the interrupt handlers short and quick.</p>
<p>Normally, once an ISR is complete the main program continues running just as it would have if the interrupt had not happened. This is a bit of a problem, though: how does your application notice that the ISR has run and done things? Seeing as an ISR doesn't have any input parameters or result, how can ISR code interact with application code?</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nvic-and-interrupt-priority"><a class="header" href="#nvic-and-interrupt-priority">NVIC and Interrupt Priority</a></h2>
<p>We've seen that interrupts make our processor immediately jump to another function in the code, but
what's going on behind the scenes to allow this to happen? In this section we'll cover some
technical details that won't be necessary for the rest of the book, so feel free to skip ahead if
you're not interested.</p>
<h3 id="the-interrupt-controller"><a class="header" href="#the-interrupt-controller">The Interrupt Controller</a></h3>
<p>Interrupts allow the processor to respond to peripheral events such as a GPIO input pin changing
state, a timer completing its cycle, or a UART receiving a new byte. The peripheral contains
circuitry that notices the event and informs a dedicated interrupt-handling peripheral. On Arm
processors, the interrupt-handling peripheral is called the NVIC — the Nested Vector Interrupt
Controller.</p>
<blockquote>
<p><strong>NOTE</strong> On other microcontroller architectures such as RISC-V the names and details discussed
here will differ, but the underlying principles are generally very similar.</p>
</blockquote>
<p>The NVIC can receive requests to trigger an interrupt from many peripherals. It's even common for a
peripheral to have multiple possible interrupts, for example a GPIO port having an interrupt for
each pin, or a UART having both a "data received" and "data finished transmission" interrupt. The
job of the NVIC is to prioritize these interrupts, remember which ones still need to be processed,
and then cause the processor to run the relevant interrupt handler code.</p>
<h3 id="interrupt-priorities"><a class="header" href="#interrupt-priorities">Interrupt Priorities</a></h3>
<p>The NVIC has a settable "priority" for each interrupt. Depending on its configuration, the NVIC can ensure the current interrupt is fully processed before a new one is executed, or it can "preempt" the processor in the middle of one interrupt in order to handle another that's higher priority.</p>
<p>Preemption allows processors to respond very quickly to critical events.  For example, a robot controller might use low-priority interrupts to manage sending status information to the operator, but also take a high-priority interrupt when a sensor detects an imminent collision so that it can immediately stop moving the motors. You wouldn't want the robot to wait until it had finished sending a data packet to get around to stopping!</p>
<p>If an equal-priority or lower-priority interrupt occurs during an ISR, it will be "pended": the NVIC will remember the new interrupt and run its ISR sometime after the current ISR completes.  When an ISR function returns the NVIC looks to see if, while the ISR was running, other interrupts have happened that need to be handled. If so, the NVIC checks the interrupt table and calls the highest-priority ISR vectored there. Otherwise, the CPU returns to the running program.</p>
<p>In embedded Rust, we can program the NVIC using the <a href="https://docs.rs/cortex-m/latest/cortex_m/peripheral/struct.NVIC.html"><code>cortex-m</code></a> crate, which provides methods to
enable and disable (called <code>unmask</code> and <code>mask</code>) interrupts, set interrupt priorities, and trigger
interrupts from software. Frameworks such as <a href="https://rtic.rs/">RTIC</a> can handle NVIC configuration for you, taking
advantage of the NVIC's flexibility to provide convenient resource sharing and task management.</p>
<p>You can read more information about the NVIC in <a href="https://developer.arm.com/documentation/ddi0337/e/Nested-Vectored-Interrupt-Controller/About-the-NVIC">Arm's documentation</a>.</p>
<h3 id="the-vector-table"><a class="header" href="#the-vector-table">The vector table</a></h3>
<p>When describing the NVIC, I said it could "cause the processor to run the relevant interrupt handler
code". But how does that actually work?</p>
<p>First, we need some way for the processor to know which code to run for each interrupt. On Cortex-M
processors, this involves a part of memory called the vector table. It is typically located at the
very start of the flash memory that contains our code, which is reprogrammed every time we upload
new code to our processor, and contains a list of addresses -- the locations in memory of every
interrupt function. The specific layout of the start of memory is defined by Arm in the
<a href="https://developer.arm.com/documentation/ddi0403/latest">Architecture Reference Manual</a>; for our purposes the important part is that bytes 64 through to 256
contain the addresses of all 48 interrupt handlers for the nRF processor we use, four bytes per
address. Each interrupt has a number, from 0 to 47. For example, <code>TIMER0</code> is interrupt number 8, and
so bytes 96 to 100 contain the four-byte address of its interrupt handler. When the NVIC tells the
processor to handle interrupt number 8, the CPU reads the address stored in those bytes and jumps
execution to it.</p>
<p>How is this vector table generated in our code? We use the <a href="https://docs.rs/cortex-m-rt"><code>cortex-m-rt</code></a> crate which handles this
for us. It provides a default interrupt for every unused position (since every position must be
filled) and allows our code to override this default whenever we want to specify our own interrupt
handler. We do this using the <code>#[interrupt]</code> macro, which requires that our function be given a
specific name related to the interrupt it handles. Then the <code>cortex-m-rt</code> crate uses its linker
script to arrange for the address of that function to be placed in the right part of memory.</p>
<p>For more details on how these interrupt handlers are managed in Rust, see the Exceptions and
Interrupts chapters in the <a href="https://docs.rust-embedded.org/book/">Embedded Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sharing-data-with-globals"><a class="header" href="#sharing-data-with-globals">Sharing Data With Globals</a></h2>
<blockquote>
<p><strong>NOTE</strong> This content is partially taken (with permission) from the blog post
<em><a href="https://onevariable.com/blog/interrupts-is-threads">Interrupts Is Threads</a></em> by James Munns, which contains more discussion about this
topic.</p>
</blockquote>
<p>As I mentioned in the last section, when an interrupt occurs we aren't passed any arguments and
cannot return any result. This makes it hard for our program interact with peripherals and other
main program state. Before worrying about this bare-metal embedded problem, it is likely worth
thinking about threads in "std" Rust.</p>
<h3 id="std-rust-sharing-data-with-a-thread"><a class="header" href="#std-rust-sharing-data-with-a-thread">"std" Rust: Sharing Data With A Thread</a></h3>
<p>In "std" Rust, we also have to think about sharing data when we do things like
spawn a thread.</p>
<p>When you want to <em>give</em> something to a thread, you might pass it into a closure by ownership.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a string in our current thread
let data = String::from("hello");

// Now spawn a new thread, and GIVE it ownership of the string
// that we just created
std::thread::spawn(move || {
    std::thread::sleep(std::time::Duration::from_millis(1000));
    println!("{data}");
});
<span class="boring">}</span></code></pre></pre>
<p>If you want to <em>share</em> something, and still have access to it in the original thread, you usually
can't pass a reference to it. If you do this:</p>
<pre><pre class="playground"><code class="language-rust">use std::{thread::{sleep, spawn}, time::Duration};

fn main() {
    // Create a string in our current thread
    let data = String::from("hello");
    
    // make a reference to pass along
    let data_ref = &amp;data;
    
    // Now spawn a new thread, and GIVE it ownership of the string
    // that we just created
    spawn(|| {
        sleep(Duration::from_millis(1000));
        println!("{data_ref}");
    });
    
    println!("{data_ref}");
}</code></pre></pre>
<p>you'll get an error like this:</p>
<pre><code class="language-text">error[E0597]: `data` does not live long enough
  --&gt; src/main.rs:6:20
   |
3  |       let data = String::from("hello");
   |           ---- binding `data` declared here
...
6  |       let data_ref = &amp;data;
   |                      ^^^^^ borrowed value does not live long enough
...
10 | /     spawn(|| {
11 | |         sleep(Duration::from_millis(1000));
12 | |         println!("{data_ref}");
13 | |     });
   | |______- argument requires that `data` is borrowed for `'static`
...
16 |   }
   |   - `data` dropped here while still borrowed
</code></pre>
<p>You need to <em>make sure the data lives long enough</em> for both the current thread and the new thread
you are creating. You can do this by putting it in an <code>Arc</code> (Atomically Reference Counted heap
allocation) like this:</p>
<pre><pre class="playground"><code class="language-rust">use std::{sync::Arc, thread::{sleep, spawn}, time::Duration};

fn main() {
    // Create a string in our current thread
    let data = Arc::new(String::from("hello"));
    
    let handle = spawn({
        // Make a copy of the handle to GIVE to the new thread.
        // Both `data` and `new_thread_data` are pointing at the
        // same string!
        let new_thread_data = data.clone();
        move || {
            sleep(Duration::from_millis(1000));
            println!("{new_thread_data}");
        }
    });
    
    println!("{data}");
    // wait for the thread to stop
    let _ = handle.join();
}</code></pre></pre>
<p>This is great! You can now access the data in both the main thread as long as you'd
like. But what if you want to <em>mutate</em> the data in both places?</p>
<p>For this, you will usually need some kind of "inner mutability" — a type that doesn't require an
<code>&amp;mut</code> to modify. On the desktop, you'd typically reach for a type like <code>Mutex</code>, <code>lock()</code>-ing it to
gain mutable access to the data.</p>
<p>That might look something like this:</p>
<pre><pre class="playground"><code class="language-rust">use std::{sync::{Arc, Mutex}, thread::{sleep, spawn}, time::Duration};

fn main() {
    // Create a string in our current thread
    let data = Arc::new(Mutex::new(String::from("hello")));
    
    // lock it from the original thread
    {
        let guard = data.lock().unwrap();
        println!("{guard}");
        // the guard is dropped here at the end of the scope!
    }
    
    let handle = spawn({
        // Make a copy of the handle, that you GIVE to the new thread.
        // Both `data` and `new_thread_data` are pointing at the
        // same `Mutex&lt;String&gt;`!
        let new_thread_data = data.clone();
        move || {
            sleep(Duration::from_millis(1000));
            {
                let mut guard = new_thread_data.lock().unwrap();
                // we can modify the data!
                guard.push_str(" | thread was here! |");                
                // the guard is dropped here at the end of the scope!
            }
        }
    });
    
    // wait for the thread to stop
    let _ = handle.join();
    {
        let guard = data.lock().unwrap();
        println!("{guard}");
        // the guard is dropped here at the end of the scope!
    }
}</code></pre></pre>
<p>If you run this code, you will see:</p>
<pre><code class="language-text">hello
hello | thread was here! |
</code></pre>
<p>Why does "std" Rust make us do this? Rust is helping us out by making us think about two things:</p>
<ol>
<li>The data lives long enough (potentially "forever"!)</li>
<li>Only one piece of code can mutably access the data at a time</li>
</ol>
<p>If Rust allowed us to access data that might not live long enough, like data borrowed from one
thread into another, things might go wrong. We might get corrupted data if the original thread ends
or panics and then the second thread tries to access the data that is now invalid. If Rust allowed
two pieces of code to try to mutate the same data at the same, we could have a data race, or the
data could end up corrupted.</p>
<h3 id="embedded-rust-sharing-data-with-an-isr"><a class="header" href="#embedded-rust-sharing-data-with-an-isr">Embedded Rust: Sharing Data With An ISR</a></h3>
<p>In embedded Rust we care about the same things when it comes to sharing data with interrupt
handlers! Similar to threads, interrupts can occur at any time, sort of like a thread waking up and
accessing some shared data. This means that the data we share with an interrupt must live long
enough, and we must be careful to ensure that our main code isn't in the middle of working with some
data shared with an ISR when that ISR gets run and <em>also</em> tries to work with the data!</p>
<p>In fact, in embedded Rust, we model interrupts in a similar way that we model threads in Rust: the
same rules apply, for the same reasons. However, in embedded Rust, we have some crucial differences:</p>
<ul>
<li>
<p>Interrupts don't work exactly like threads: we set them up ahead of time, and they wait until some
event happens (like a button being pressed, or a timer expiring). At that point they run, but
without access to any passed-in context.</p>
</li>
<li>
<p>Interrupts can be triggered multiple times, once for each time that the event occurs.</p>
</li>
</ul>
<p>Since we can't pass context to interrupts as function arguments, we need to find another place to
store that data. In "bare metal" embedded Rust we don't have access to heap allocations: thus <code>Arc</code>
and similar are not possibilities for us.</p>
<p>Without the ability to pass things by value, and without a heap to store data, that leaves us with
one place to put our shared data that our ISR can access: <code>static</code> globals.</p>
<h3 id="embedded-rust-isr-data-sharing-the-standard-method"><a class="header" href="#embedded-rust-isr-data-sharing-the-standard-method">Embedded Rust ISR Data Sharing: The "Standard Method"</a></h3>
<p>Global variables are very much second-class citizens in Rust, with many limitations compared to
local variables. You can declare a global state variable like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static COUNTER: usize = 0;
<span class="boring">}</span></code></pre></pre>
<p>Of course, this isn't super-useful: you want to be able to mutate the <code>COUNTER</code>. You can
say</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut COUNTER: usize = 0;
<span class="boring">}</span></code></pre></pre>
<p>but now all accesses will be unsafe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe { COUNTER += 1 };
<span class="boring">}</span></code></pre></pre>
<p>The unsafety here is for a reason: imagine that in the middle of updating <code>COUNTER</code> an interrupt
handler runs and also tries to update <code>COUNTER</code>. The usual chaos will ensue. Clearly some kind of
locking is in order.</p>
<p>The <code>critical-section</code> crate provides a sort of <code>Mutex</code> type, but with an unusual API and unusual
operations. Examining the <code>Cargo.toml</code> for this chapter, you will see the feature
<code>critical-section-single-core</code> on the <code>cortex-m</code> crate enabled. This feature asserts that there is
only one processor core in this system, and that thus synchronization can be performed by simply
<em>disabling interrupts</em> across the critical section. If not in an interrupt, this will ensure that
only the main program has access to the global. If in an interrupt, this will ensure that the main
program cannot be accessing the global (program control is in the interrupt handler) and that no
other higher-priority interrupt handler can fire.</p>
<p><code>critical_section::Mutex</code> is a bit weird in that it gives mutual exclusion but does not itself give
mutability. To make the data mutable, you will need to protect an interior-mutable type — usually
<code>RefCell</code> — with the mutex. This <code>Mutex</code> is also a bit weird in that you don't <code>.lock()</code>
it. Instead, you initiate a critical section with a closure that receives a "critical section token"
certifying that other program execution is prevented. This token can be passed to the <code>Mutex</code>'s
<code>borrow()</code> method to allow access.</p>
<p>Putting it all together gives you the ability to share state between ISRs and the main program
(<code>examples/count-once.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::cell::RefCell;

use cortex_m::asm;
use cortex_m_rt::entry;
use critical_section::Mutex;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    Board,
    hal::{
        gpiote,
        pac::{self, interrupt},
    },
};

static COUNTER: Mutex&lt;RefCell&lt;usize&gt;&gt; = Mutex::new(RefCell::new(0));

/// This "function" will be called when an interrupt is received. For now, just
/// report and panic.
#[interrupt]
fn GPIOTE() {
    critical_section::with(|cs| {
        let mut count = COUNTER.borrow(cs).borrow_mut();
        *count += 1;
        rprintln!("count: {}", count);
    });
    panic!();
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let button_a = board.buttons.button_a.into_floating_input();

    // Set up the GPIOTE to generate an interrupt when Button A is pressed (GPIO
    // wire goes low).
    let gpiote = gpiote::Gpiote::new(board.GPIOTE);
    let channel = gpiote.channel0();
    channel
        .input_pin(&amp;button_a.degrade())
        .hi_to_lo()
        .enable_interrupt();
    channel.reset_events();

    // Set up the NVIC to handle GPIO interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::GPIOTE) };
    pac::NVIC::unpend(pac::Interrupt::GPIOTE);

    loop {
        // "wait for interrupt": CPU goes to sleep until an interrupt.
        asm::wfi();
    }
}</code></pre></pre>
<p>You still cannot safely return from your ISR, but now you are in a position to do something about
that: share the <code>GPIOTE</code> with the ISR so that the ISR can clear the interrupt.</p>
<h3 id="sharing-peripherals-etc-with-globals"><a class="header" href="#sharing-peripherals-etc-with-globals">Sharing Peripherals (etc) With Globals</a></h3>
<p>There's one more problem yet to solve: Rust globals must be initialized statically — before the
program starts. For the counter that was easy — just initialize it to 0. If you want to share the
<code>GPIOTE</code> peripheral, though, that won't work. The peripheral must be retrieved from the <code>Board</code>
struct and set up once the program has started: there is no <code>const</code> initializer for this (nor can
there reasonably be).</p>
<p>Let's rewrite the button counter a bit. First, move the actual count to be an <code>AtomicUsize</code>. This is
a more natural type for this global anyhow. Next, add a global <code>GPIOTE_PERIPHERAL</code> variable using
the <code>LockMut</code> type from the <code>critical-section-lock-mut</code> crate. This crate is a convenient wrapper
for the pattern of the last section.</p>
<p>Now that the main program can set up the GPIOTE peripheral and then make it available to the
interrupt handler, you can quit panicking and let the counter bump up on every button press. Move
the count display into the main loop, to show that the count is shared between the interrupt handler
and the rest of the program.</p>
<p>Give this example (<code>examples/count.rs</code>) a run and note that the count is bumped up 1 on every push
of the MB2 A button.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::sync::atomic::{AtomicUsize, Ordering::AcqRel};

use cortex_m::asm;
use cortex_m_rt::entry;
use critical_section_lock_mut::LockMut;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    Board,
    hal::{
        gpiote,
        pac::{self, interrupt},
    },
};

static COUNTER: AtomicUsize = AtomicUsize::new(0);
static GPIOTE_PERIPHERAL: LockMut&lt;gpiote::Gpiote&gt; = LockMut::new();

#[interrupt]
fn GPIOTE() {
    let count = COUNTER.fetch_add(1, AcqRel);
    rprintln!("ouch {}", count + 1);
    GPIOTE_PERIPHERAL.with_lock(|gpiote| {
        gpiote.channel0().reset_events();
    });
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let button_a = board.buttons.button_a.into_floating_input();

    // Set up the GPIOTE to generate an interrupt when Button A is pressed (GPIO
    // wire goes low).
    let gpiote = gpiote::Gpiote::new(board.GPIOTE);
    let channel = gpiote.channel0();
    channel
        .input_pin(&amp;button_a.degrade())
        .hi_to_lo()
        .enable_interrupt();
    channel.reset_events();
    GPIOTE_PERIPHERAL.init(gpiote);

    // Set up the NVIC to handle GPIO interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::GPIOTE) };
    pac::NVIC::unpend(pac::Interrupt::GPIOTE);

    loop {
        // "wait for interrupt": CPU goes to sleep until an interrupt.
        asm::wfi();
    }
}</code></pre></pre>
<blockquote>
<p><strong>NOTE</strong> It is always a good idea to compile examples involving interrupt handling with
<code>--release</code>. Long interrupt handlers can lead to a lot of confusion.</p>
</blockquote>
<p>Really, though, that <code>rprintln!()</code> in the interrupt handler is bad practice: while the interrupt
handler is running the printing code, nothing else can move forward. Let's move the reporting to the
main loop, just after the <code>wfi()</code> "wait for interrupt". The count will then be reported every time
an interrupt handler finishes (<code>examples/count-bounce.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::sync::atomic::{AtomicUsize, Ordering::{Acquire, AcqRel}};

use cortex_m::asm;
use cortex_m_rt::entry;
use critical_section_lock_mut::LockMut;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    Board,
    hal::{
        gpiote,
        pac::{self, interrupt},
    },
};

static COUNTER: AtomicUsize = AtomicUsize::new(0);
static GPIOTE_PERIPHERAL: LockMut&lt;gpiote::Gpiote&gt; = LockMut::new();

#[interrupt]
fn GPIOTE() {
    let _ = COUNTER.fetch_add(1, AcqRel);
    GPIOTE_PERIPHERAL.with_lock(|gpiote| {
        gpiote.channel0().reset_events();
    });
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let button_a = board.buttons.button_a.into_floating_input();

    // Set up the GPIOTE to generate an interrupt when Button A is pressed (GPIO
    // wire goes low).
    let gpiote = gpiote::Gpiote::new(board.GPIOTE);
    let channel = gpiote.channel0();
    channel
        .input_pin(&amp;button_a.degrade())
        .hi_to_lo()
        .enable_interrupt();
    channel.reset_events();
    GPIOTE_PERIPHERAL.init(gpiote);

    // Set up the NVIC to handle GPIO interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::GPIOTE) };
    pac::NVIC::unpend(pac::Interrupt::GPIOTE);

    loop {
        // "wait for interrupt": CPU goes to sleep until an interrupt.
        asm::wfi();
        let count = COUNTER.load(Acquire);
        rprintln!("ouch {}", count);
    }
}</code></pre></pre>
<p>In this example the count is bumped up 1 on every push of the MB2 A button. Maybe. Especially if
your MB2 is old (!), you may see a single press bump the counter by several. <em>This is not a software
bug.</em> Mostly. In the next section, I'll talk about what might be going on and how we should deal
with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="debouncing"><a class="header" href="#debouncing">Debouncing</a></h2>
<p>As I mentioned in the last section, hardware can be a little… special. This is definitely the case
for the buttons on the MB2, and really for almost any pushbutton or switch in almost any system. If
you are seeing several interrupts for a single keypress, it is probably the result of what is known
as switch "bouncing". This is literally what the name implies: as the electrical contacts of the
switch come together, they may bounce apart and then recontact several times rather quickly before
establishing a solid connection. Unfortunately, our microprocessor is <em>very</em> fast by mechanical
standards: each one of these bounces makes a new interrupt.</p>
<p>To "debounce" the switch, you need to <em>not</em> process button press interrupts for a short time after
you receive one. 50-100ms is typically a good debounce interval. Debounce timing seems hard: you
definitely don't want to spin in an interrupt handler, and yet it would be hard to deal with this in
the main program.</p>
<p>The solution comes through another form of hardware concurrency: the <code>TIMER</code> peripheral we have used
a bunch already. You can set the timer when a "good" button interrupt is received, and not respond
to further interrupts for that button until the timer peripheral has counted enough time off. The
timers in <code>nrf-hal</code> come configured with a 32-bit count value and a "tick rate" of 1 MHz: a million
ticks per second. For a 100ms debounce, just let the timer count off 100,000 ticks. Anytime the
button interrupt handler sees that the timer is running, it can just do nothing.</p>
<p>The implementation of all this can be seen in the next example (<code>examples/count-debounce.rs</code>). When
you run the example you should see one count per button press.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::sync::atomic::{
    AtomicUsize,
    Ordering::{AcqRel, Acquire},
};

use cortex_m::asm;
use cortex_m_rt::entry;
use critical_section_lock_mut::LockMut;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    hal::{
        self, gpiote,
        pac::{self, interrupt},
    },
    Board,
};

static COUNTER: AtomicUsize = AtomicUsize::new(0);
static GPIOTE_PERIPHERAL: LockMut&lt;gpiote::Gpiote&gt; = LockMut::new();
static DEBOUNCE_TIMER: LockMut&lt;hal::Timer&lt;pac::TIMER0&gt;&gt; = LockMut::new();

// 100ms at 1MHz count rate.
const DEBOUNCE_TIME: u32 = 100 * 1_000_000 / 1000;

#[interrupt]
fn GPIOTE() {
    DEBOUNCE_TIMER.with_lock(|debounce_timer| {
        if debounce_timer.read() == 0 {
            let _ = COUNTER.fetch_add(1, AcqRel);
            debounce_timer.start(DEBOUNCE_TIME);
        }
    });
    GPIOTE_PERIPHERAL.with_lock(|gpiote| {
        gpiote.channel0().reset_events();
    });
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let button_a = board.buttons.button_a.into_floating_input();

    // Set up the GPIOTE to generate an interrupt when Button A is pressed (GPIO
    // wire goes low).
    let gpiote = gpiote::Gpiote::new(board.GPIOTE);
    let channel = gpiote.channel0();
    channel
        .input_pin(&amp;button_a.degrade())
        .hi_to_lo()
        .enable_interrupt();
    channel.reset_events();
    GPIOTE_PERIPHERAL.init(gpiote);

    // Set up the debounce timer.
    let mut debounce_timer = hal::Timer::new(board.TIMER0);
    debounce_timer.disable_interrupt();
    debounce_timer.reset_event();
    DEBOUNCE_TIMER.init(debounce_timer);

    // Set up the NVIC to handle interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::GPIOTE) };
    pac::NVIC::unpend(pac::Interrupt::GPIOTE);

    let mut cur_count = 0;
    loop {
        // "wait for interrupt": CPU goes to sleep until an interrupt.
        asm::wfi();
        let count = COUNTER.load(Acquire);
        if count &gt; cur_count {
            rprintln!("ouch {}", count);
            cur_count = count;
        }
    }
}</code></pre></pre>
<p><strong>NOTE</strong> The buttons on the MB2 are a little fiddly: it's pretty easy to push one down enough to
feel a "click" but not enough to actually make contact with the switch. I recommend using a
fingernail to press the button when testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waiting-for-an-interrupt"><a class="header" href="#waiting-for-an-interrupt">Waiting for an interrupt</a></h1>
<p>You may have wondered why we have been using <code>asm::wfi()</code> (wait for instruction) in our main loop instead of something like <code>asm::nop()</code>.</p>
<p>As discussed before, <code>asm::nop()</code> means no-op(eration), and is an instruction that the CPU executes without doing anything .  We definitely could have used <code>asm::nop()</code> in our main loop instead, and the program would have behaved the same way.  The microcontroller, on the other hand, would behave differently.</p>
<p>Calling <code>asm::wfi()</code> puts the CPU into "Wait For Interrupt" (WFI) mode.  When the CPU is in WFI mode, it will sleep until an interrupt wakes it up.  During sleep, the CPU will stop fetching instructions, turn off some clocks and peripherals, and enter a low-power state, but still keep the core running.  When an interrupt occurs, the CPU will wake up and execute as normal.</p>
<p>The main difference between <code>asm::wfi()</code> and <code>asm::nop()</code> is that the NOP instruction completes immediately, and will thus be run repeatedly in a loop.  The NOP still needs to be fetched from the program memory and be executed even though the execution doesn't do anything.  Most microcontrollers you'll find out there have a low-power mode (some even have several, each with varying things staying on and each with different power consumption characteristics) that can (and should in a lot of cases) be used to save power. The WFI instruction halts execution <em>in a low-power mode</em> until an interrupt is received.</p>
<p>You'll find some interrupt-driven programs that consist of nothing but <code>asm::wfi()</code> in the main loop, with all program logic being implemented in the interrupt handlers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-mb2-speaker"><a class="header" href="#the-mb2-speaker">The MB2 Speaker</a></h1>
<p>Your MB2 has a built-in speaker — the large black square device labeled "SPEAKER" in the middle of
the back of the board.</p>
<p>The speaker works by moving air in response to a GPIO pin: when the speaker pin is high (3.3V) a
diaphragm inside — the "speaker cone" — is pushed all the way out; when the speaker pin is low (GND)
it is pulled all the way back in. As air is pushed out and sucked back in, it flows in and out of
the tiny rectangular hole — the "speaker port" — on the side of the device.  Do this fast enough,
and the pressure changes will make a sound.</p>
<img class="white_bg" height="350" title="Speaker" src="15-interrupts/../assets/speaker.svg" />
<p>With the right hardware driving it, this speaker cone could actually be moved to any position in its
range with an appropriate current. This would allow fairly good reproduction of any sound, like a
"normal" speaker. Unfortunately, limitations in the MB2 hardware controlling the speaker mean that
only the full-in and full-out positions are readily available.</p>
<p>Let's push the speaker cone out and then in 220 times per second. This will produce a "square"
220-cycles-per-second pressure wave. The unit "cycles-per-second" is Hertz; we will be producing a
220Hz tone (a musical "A3"), which is not unpleasant on this shrill speaker.</p>
<p>We'll make our tone play for five seconds and then stop. It is important to remember that our
program lives in flash on the MB2 — the tone will start up again each time we reset or even power on
the MB2. If we let the tone run forever, this behavior can rapidly become quite annoying.</p>
<p>Here's the code (<code>examples/square-wave.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm;
use cortex_m_rt::entry;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::{
    Board,
    hal::{gpio, timer},
};

/// The "period" is the time per cycle. It is
/// 1/f where f is the frequency in Hz. In this
/// case we measure time in milliseconds.
const PERIOD: u32 = 1000 / 220;

/// Number of cycles for 5 seconds of output.
const CYCLES: u32 = 5000 / PERIOD;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut speaker_pin = board.speaker_pin.into_push_pull_output(gpio::Level::Low);
    let mut timer = timer::Timer::new(board.TIMER0);

    for _ in 0..CYCLES {
        speaker_pin.set_high().unwrap();
        timer.delay_ms(PERIOD / 2);
        speaker_pin.set_low().unwrap();
        timer.delay_ms(PERIOD / 2);
    }
    
    loop {
        asm::wfi();
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-5"><a class="header" href="#the-challenge-5">The Challenge</a></h1>
<p>Let's make the MB2 into a siren! But not just any siren — an
interrupt-driven siren. That way we can turn the siren on
and the rest of our program can run on, ignoring it.</p>
<p>Make your siren sweep the pitch from 220Hz to 440Hz and back
over a one-second period. The main program should start the
siren, then print a ten-second countdown from 10 to 1, then
stop the siren and print "launch!". The main program should
not mess with the siren during countdown — it should just be
interrupt-driven.</p>
<p><em>Hint:</em> I found it easiest to use a global locked <code>Siren</code>
struct that owned the state of the siren and the peripherals
it needed to operate.</p>
<p>This is a fancy program that introduces a lot of new
ideas. Don't be surprised if it takes you a bit to figure it
out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-6"><a class="header" href="#my-solution-6">My Solution</a></h1>
<p>I found it a bit tricky to figure out how the interrupt
handler should calculate the next interrupt time to keep
the siren going. I ended up with a couple of state variables
to keep track of whether the speaker pin was on or off
(could have checked the hardware) and to keep track of what
time the siren was at in its up-down cycle.</p>
<p>My code contains all the details (<code>src/main.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm;
use cortex_m_rt::entry;
use critical_section_lock_mut::LockMut;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use panic_rtt_target as _;
use rtt_target::{rtt_init_print, rprintln};

use microbit::{
    Board,
    hal::{gpio, timer, pac::{self, interrupt}},
};

/// Base siren frequency in Hz.
const BASE_FREQ: u32 = 440;
/// Max rise in siren frequency in Hz.
const FREQ_RISE: u32 = 220;
/// Time for one full cycle in µs.
const RISE_TIME: u32 = 500_000;

/// These convenience types make life easier.
type SpeakerPin = gpio::Pin&lt;gpio::Output&lt;gpio::PushPull&gt;&gt;;
type SirenTimer = timer::Timer&lt;pac::TIMER0&gt;;

/// The current state of the siren. Updated by the interrupt
/// handler when running.
struct Siren {
    /// The timer being used by the siren.
    timer: SirenTimer,
    /// The MB2 speaker pin. Needs to be owned
    /// here for the interrupt handler.
    speaker_pin: SpeakerPin,
    /// Is the speaker pin currently high or low?
    pin_high: bool,
    /// Time in µs since the start of the current siren cycle.
    cur_time: u32,
}

impl Siren {
    /// Make a new siren with the given peripherals.
    fn new(speaker_pin: SpeakerPin, timer: SirenTimer) -&gt; Self {
        Self {
            timer,
            speaker_pin,
            pin_high: false,
            cur_time: 0,
        }
    }

    /// Start the siren running.
    fn start(&amp;mut self) {
        self.speaker_pin.set_low().unwrap();
        self.pin_high = false;
        self.cur_time = 0;
        self.timer.enable_interrupt();
        // The timer interval is in ticks.
        // The [nrf52833_hal] timer is hard-wired to 1M ticks/sec.
        self.timer.start(1_000_000 / BASE_FREQ);
    }

    /// Stop the siren.
    fn stop(&amp;mut self) {
        self.timer.disable_interrupt();
    }

    /// Step the siren to the current speaker state change.
    /// This is normally called from the timer interrupt.
    fn step(&amp;mut self) {
        // Flip the speaker pin.
        if self.pin_high {
            self.speaker_pin.set_low().unwrap();
            self.pin_high = false;
        } else {
            self.speaker_pin.set_high().unwrap();
            self.pin_high = true;
        }

        // Figure out the next period. The math is a little
        // special here.

        // First, wrap to the next siren cycle if needed.
        while self.cur_time &gt;= 2 * RISE_TIME {
            self.cur_time -= 2 * RISE_TIME;
        }
        // Next, figure out where we are in the current siren cycle.
        let cycle_time = if self.cur_time &lt; RISE_TIME {
            self.cur_time
        } else {
            2 * RISE_TIME - self.cur_time
        };
        // Finally, calculate the frequency and period.
        let frequency = BASE_FREQ + FREQ_RISE * cycle_time / RISE_TIME;
        let period = 1_000_000 / frequency;

        // Anticipate the time of the next interrupt.
        self.cur_time += period / 2;

        // Make sure to clear the current interrupt before
        // starting the next one, else you might get interrupted
        // again immediately.
        self.timer.reset_event();
        self.timer.start(period / 2);
    }
}

/// The siren. Accessible from both the interrupt handler
/// and the main program.
static SIREN: LockMut&lt;Siren&gt; = LockMut::new();

/// The timer interrupt for the siren. Just steps the siren.
#[interrupt]
fn TIMER0() {
    SIREN.with_lock(|siren| siren.step());
}

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    // It is convenient to use a `degrade()`ed pin
    // to avoid having to deal with the type of the
    // speaker pin, rather than looking it up:
    // the pin is stored globally in `SIREN`, so its
    // size must be known.
    //
    // This does lose type safety, but that is unlikely
    // to matter after this point.
    let speaker_pin = board.speaker_pin
        .into_push_pull_output(gpio::Level::Low)
        .degrade();
    let timer0 = timer::Timer::new(board.TIMER0);
    let mut timer1 = timer::Timer::new(board.TIMER1);

    // Set up the NVIC to handle interrupts.
    unsafe { pac::NVIC::unmask(pac::Interrupt::TIMER0) };
    pac::NVIC::unpend(pac::Interrupt::TIMER0);

    // Place the siren struct where the interrupt handler can find it.
    let siren = Siren::new(speaker_pin, timer0);
    SIREN.init(siren);

    // Start the siren and do the countdown.
    SIREN.with_lock(|siren| siren.start());
    for t in (1..=10).rev() {
        rprintln!("{}", t);
        timer1.delay_ms(1_000);
    }
    rprintln!("launch!");
    SIREN.with_lock(|siren| siren.stop());
    
    loop {
        asm::wfi();
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addendum-pwm"><a class="header" href="#addendum-pwm">Addendum: PWM</a></h1>
<p>One last note before we move on.</p>
<p>Interrupts are kind of expensive. The processor must finish
or abort the currently-running instruction, then save enough
state to restart execution, then call an interrupt
handler. All this takes a few CPU cycles of precious
runtime.</p>
<p>The way the solution of the previous section is written, it
will take two interrupts per cycle of speaker output. That's
something like 1000 interrupts per second. On a processor
like our nRF52833, that works fine.</p>
<p>The nRF52833 does have an on-board peripheral that could cut
our siren's interrupt rate way down. The Pulse-Width
Modulation (PWM) unit can, among other things, generate
cycles on the speaker pin at a rate controlled by a PWM
register. This could be used to generate the basic square
wave used for our siren. We would still need an interrupt
every time we wanted to change the frequency, but this might
be more like 10 interrupts per second than 1000.</p>
<p>I did not use the PWM unit in my solution. This was partly
because I wanted to focus on interrupts. Another big reason,
though, was that the nRF52833 PWM unit is pretty complicated
and hard to understand. Getting something working a simple
way in the tight bare-metal environment is always
attractive.</p>
<p>If you are up for a challenge, I would encourage you to try
using the PWM unit for your siren.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snake-game"><a class="header" href="#snake-game">Snake game</a></h1>
<p>We're now going to implement a basic <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">snake</a>
game that you can play on an MB2 using its 5×5 LED matrix as a display and its two buttons as
controls. In doing so, we will build on some of the concepts covered in the earlier chapters of this
book, and also learn about some new peripherals and concepts.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>The source code here is more modular than it probably should be. This fine-grained modularity allows
us to look at the source code a little at a time. We will build the code bottom-up: we will first
build three modules — <code>game</code>, <code>controls</code> and <code>display</code>, and then compose these to build the final
program. Each module will have a top-level source file and one or more included source files: for
example, the <code>game</code> module will consist of <code>src/game.rs</code>, <code>src/game/coords.rs</code>,
<code>src/game/movement.rs</code>, etc. The Rust <code>mod</code> statement is used to combine the various components of
the module. <em>The Rust Programming Language</em> has a good <a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">description</a> of Rust's module system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-logic"><a class="header" href="#game-logic">Game logic</a></h1>
<p>The first module we will build is the game logic. You are probably familiar with <a href="https://en.wikipedia.org/wiki/Snake_%28video_game_genre%29">snake</a> games, but
if not, the basic idea is that the player guides a snake around a 2D grid. At any given time, there
is some "food" at a random location on the grid and the goal of the game is to get the snake to
"eat" as much food as possible. Each time the snake eats food it grows in length. The player loses
if the snake crashes into its own tail.</p>
<p>In some variants of the game, the player also loses if the snake crashes into the edge of the grid,
but given the small size of our grid we are going to implement a "wraparound" rule: if the snake
goes off one edge of the grid, it will continue from the opposite edge.</p>
<h2 id="the-game-module"><a class="header" href="#the-game-module">The <code>game</code> module</a></h2>
<p>We will build up the game mechanics in the <code>game</code> module.</p>
<h3 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h3>
<p>We start by defining a coordinate system for our game (<code>src/game/coords.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Prng;

use heapless::FnvIndexSet;

/// A single point on the grid.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct Coords {
    // Signed ints to allow negative values (handy when checking if we have gone
    // off the top or left of the grid)
    pub row: i8,
    pub col: i8,
}

impl Coords {
    /// Get random coordinates within a grid. `exclude` is an optional set of
    /// coordinates which should be excluded from the output.
    pub fn random(rng: &amp;mut Prng, exclude: Option&lt;&amp;FnvIndexSet&lt;Coords, 32&gt;&gt;) -&gt; Self {
        let mut coords = Coords {
            row: ((rng.random_u32() as usize) % 5) as i8,
            col: ((rng.random_u32() as usize) % 5) as i8,
        };
        while exclude.is_some_and(|exc| exc.contains(&amp;coords)) {
            coords = Coords {
                row: ((rng.random_u32() as usize) % 5) as i8,
                col: ((rng.random_u32() as usize) % 5) as i8,
            }
        }
        coords
    }

    /// Whether the point is outside the bounds of the grid.
    pub fn is_out_of_bounds(&amp;self) -&gt; bool {
        self.row &lt; 0 || self.row &gt;= 5 || self.col &lt; 0 || self.col &gt;= 5
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We use a <code>Coords</code> struct to refer to a position on the grid. Because <code>Coords</code> only contains two
integers, we tell the compiler to derive an implementation of the <code>Copy</code> trait for it, so we can
pass around <code>Coords</code> structs without having to worry about ownership.</p>
<h3 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h3>
<p>We define an associated function, <code>Coords::random</code>, which will give us a random position on the
grid. We will use this later to determine where to place the snake's food.</p>
<p>To generate random coordinates, we need a source of random numbers. The nRF52833 has a hardware
random number generator (HWRNG) peripheral, documented at section 6.19 of the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf">nRF52833 spec</a>. The
HAL gives us a simple interface to the HWRNG via the <code>microbit::hal::rng::Rng</code> struct. The HWRNG may
not be fast enough for a game; it is also convenient for testing to be able to replicate the
sequence of random numbers produced by the generator between runs, which is impossible for the HWRNG
by design. We thus also define a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random</a> number generator (PRNG). The PRNG uses an
<a href="https://en.wikipedia.org/wiki/Xorshift">xorshift</a> algorithm to generate pseudo-random <code>u32</code> values. The algorithm is basic and not
cryptographically secure, but it is efficient, easy to implement and good enough for our humble
snake game. Our <code>Prng</code> struct requires an initial seed value, which we do get from the RNG
peripheral.</p>
<p>All of this makes up <code>src/game/rng.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::Rng;

/// A basic pseudo-random number generator.
pub struct Prng {
    value: u32,
}

impl Prng {
    pub fn seeded(rng: &amp;mut Rng) -&gt; Self {
        Self::new(rng.random_u32())
    }

    pub fn new(seed: u32) -&gt; Self {
        Self { value: seed }
    }

    /// Basic xorshift PRNG function: see &lt;https://en.wikipedia.org/wiki/Xorshift&gt;
    fn xorshift32(mut input: u32) -&gt; u32 {
        input ^= input &lt;&lt; 13;
        input ^= input &gt;&gt; 17;
        input ^= input &lt;&lt; 5;
        input
    }

    /// Return a pseudo-random u32.
    pub fn random_u32(&amp;mut self) -&gt; u32 {
        self.value = Self::xorshift32(self.value);
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="movement"><a class="header" href="#movement">Movement</a></h3>
<p>We also need to define a few <code>enum</code>s that help us manage the game's state: direction of movement,
direction to turn, the current game status and the outcome of a particular "step" in the game (ie, a
single movement of the snake). <code>src/game/movement.rs</code> contains these.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Coords;

/// Define the directions the snake can move.
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
}

/// What direction the snake should turn.
#[derive(Debug, Copy, Clone)]
pub enum Turn {
    Left,
    Right,
    None,
}

/// The current status of the game.
pub enum GameStatus {
    Won,
    Lost,
    Ongoing,
}

/// The outcome of a single move/step.
pub enum StepOutcome {
    /// Grid full (player wins)
    Full,
    /// Snake has collided with itself (player loses)
    Collision,
    /// Snake has eaten some food
    Eat(Coords),
    /// Snake has moved (and nothing else has happened)
    Move(Coords),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="a-snake-a-snaaake"><a class="header" href="#a-snake-a-snaaake">A Snake (<em>A Snaaake!</em>)</a></h3>
<p>Next up we define a <code>Snake</code> struct, which keeps track of the coordinates occupied by the snake and
its direction of travel. We use a queue (<code>heapless::spsc::Queue</code>) to keep track of the order of
coordinates and a hash set (<code>heapless::FnvIndexSet</code>) to allow for quick collision detection.  The
<code>Snake</code> has methods to allow it to move. <code>src/game/snake.rs</code> gets this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Coords, Direction, FnvIndexSet, Turn};

use heapless::spsc::Queue;

pub struct Snake {
    /// Coordinates of the snake's head.
    pub head: Coords,
    /// Queue of coordinates of the rest of the snake's body. The end of the tail is
    /// at the front.
    pub tail: Queue&lt;Coords, 32&gt;,
    /// A set containing all coordinates currently occupied by the snake (for fast
    /// collision checking).
    pub coord_set: FnvIndexSet&lt;Coords, 32&gt;,
    /// The direction the snake is currently moving in.
    pub direction: Direction,
}

impl Snake {
    pub fn make_snake() -&gt; Self {
        let head = Coords { row: 2, col: 2 };
        let initial_tail = Coords { row: 2, col: 1 };
        let mut tail = Queue::new();
        tail.enqueue(initial_tail).unwrap();
        let mut coord_set: FnvIndexSet&lt;Coords, 32&gt; = FnvIndexSet::new();
        coord_set.insert(head).unwrap();
        coord_set.insert(initial_tail).unwrap();
        Self {
            head,
            tail,
            coord_set,
            direction: Direction::Right,
        }
    }

    /// Move the snake onto the tile at the given coordinates. If `extend` is false,
    /// the snake's tail vacates the rearmost tile.
    pub fn move_snake(&amp;mut self, coords: Coords, extend: bool) {
        // Location of head becomes front of tail
        self.tail.enqueue(self.head).unwrap();
        // Head moves to new coords
        self.head = coords;
        self.coord_set.insert(coords).unwrap();
        if !extend {
            let back = self.tail.dequeue().unwrap();
            self.coord_set.remove(&amp;back);
        }
    }

    fn turn_right(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Right,
            Direction::Down =&gt; Direction::Left,
            Direction::Left =&gt; Direction::Up,
            Direction::Right =&gt; Direction::Down,
        }
    }

    fn turn_left(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Left,
            Direction::Down =&gt; Direction::Right,
            Direction::Left =&gt; Direction::Down,
            Direction::Right =&gt; Direction::Up,
        }
    }

    pub fn turn(&amp;mut self, direction: Turn) {
        match direction {
            Turn::Left =&gt; self.turn_left(),
            Turn::Right =&gt; self.turn_right(),
            Turn::None =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="game-module-top-level"><a class="header" href="#game-module-top-level">Game Module Top-Level</a></h3>
<p>The <code>Game</code> struct keeps track of the game state. It holds a <code>Snake</code> object, the current coordinates
of the food, the speed of the game (which is used to determine the time that elapses between each
movement of the snake), the status of the game (whether the game is ongoing or the player has won or
lost) and the player's score.</p>
<p>This struct contains methods to handle each step of the game, determining the snake's next move and
updating the game state accordingly. It also contains two methods--<code>game_matrix</code> and
<code>score_matrix</code>--that output 2D arrays of values which can be used to display the game state or the
player score on the LED matrix (as we will see later).</p>
<p>We put the <code>Game</code> struct at the top of the <code>game</code> module, in <code>src/game.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod coords;
mod movement;
mod rng;
mod snake;

use crate::Rng;

pub use coords::Coords;
pub use movement::{Direction, GameStatus, StepOutcome, Turn};
pub use rng::Prng;
pub use snake::Snake;

use heapless::FnvIndexSet;

/// Struct to hold game state and associated behaviour
pub struct Game {
    pub status: GameStatus,
    rng: Prng,
    snake: Snake,
    food_coords: Coords,
    speed: u8,
    score: u8,
}

impl Game {
    pub fn new(rng: &amp;mut Rng) -&gt; Self {
        let mut rng = Prng::seeded(rng);
        let snake = Snake::make_snake();
        let food_coords = Coords::random(&amp;mut rng, Some(&amp;snake.coord_set));
        Self {
            rng,
            snake,
            food_coords,
            speed: 1,
            status: GameStatus::Ongoing,
            score: 0,
        }
    }

    /// Reset the game state to start a new game.
    pub fn reset(&amp;mut self) {
        self.snake = Snake::make_snake();
        self.place_food();
        self.speed = 1;
        self.status = GameStatus::Ongoing;
        self.score = 0;
    }

    /// Randomly place food on the grid.
    fn place_food(&amp;mut self) -&gt; Coords {
        let coords = Coords::random(&amp;mut self.rng, Some(&amp;self.snake.coord_set));
        self.food_coords = coords;
        coords
    }

    /// "Wrap around" out of bounds coordinates (eg, coordinates that are off to the
    /// left of the grid will appear in the rightmost column). Assumes that
    /// coordinates are out of bounds in one dimension only.
    fn wraparound(&amp;self, coords: Coords) -&gt; Coords {
        if coords.row &lt; 0 {
            Coords { row: 4, ..coords }
        } else if coords.row &gt;= 5 {
            Coords { row: 0, ..coords }
        } else if coords.col &lt; 0 {
            Coords { col: 4, ..coords }
        } else {
            Coords { col: 0, ..coords }
        }
    }

    /// Determine the next tile that the snake will move on to (without actually
    /// moving the snake).
    fn get_next_move(&amp;self) -&gt; Coords {
        let head = &amp;self.snake.head;
        let next_move = match self.snake.direction {
            Direction::Up =&gt; Coords {
                row: head.row - 1,
                col: head.col,
            },
            Direction::Down =&gt; Coords {
                row: head.row + 1,
                col: head.col,
            },
            Direction::Left =&gt; Coords {
                row: head.row,
                col: head.col - 1,
            },
            Direction::Right =&gt; Coords {
                row: head.row,
                col: head.col + 1,
            },
        };
        if next_move.is_out_of_bounds() {
            self.wraparound(next_move)
        } else {
            next_move
        }
    }

    /// Assess the snake's next move and return the outcome. Doesn't actually update
    /// the game state.
    fn get_step_outcome(&amp;self) -&gt; StepOutcome {
        let next_move = self.get_next_move();
        if self.snake.coord_set.contains(&amp;next_move) {
            // We haven't moved the snake yet, so if the next move is at the end of
            // the tail, there won't actually be any collision (as the tail will have
            // moved by the time the head moves onto the tile)
            if next_move != *self.snake.tail.peek().unwrap() {
                StepOutcome::Collision
            } else {
                StepOutcome::Move(next_move)
            }
        } else if next_move == self.food_coords {
            if self.snake.tail.len() == 23 {
                StepOutcome::Full
            } else {
                StepOutcome::Eat(next_move)
            }
        } else {
            StepOutcome::Move(next_move)
        }
    }

    /// Handle the outcome of a step, updating the game's internal state.
    fn handle_step_outcome(&amp;mut self, outcome: StepOutcome) {
        self.status = match outcome {
            StepOutcome::Collision =&gt; GameStatus::Lost,
            StepOutcome::Full =&gt; GameStatus::Won,
            StepOutcome::Eat(c) =&gt; {
                self.snake.move_snake(c, true);
                self.place_food();
                self.score += 1;
                if self.score % 5 == 0 {
                    self.speed += 1
                }
                GameStatus::Ongoing
            }
            StepOutcome::Move(c) =&gt; {
                self.snake.move_snake(c, false);
                GameStatus::Ongoing
            }
        }
    }

    pub fn step(&amp;mut self, turn: Turn) {
        self.snake.turn(turn);
        let outcome = self.get_step_outcome();
        self.handle_step_outcome(outcome);
    }

    /// Calculate the length of time to wait between game steps, in milliseconds.
    /// Generally this will get lower as the player's score increases, but need to
    /// be careful it cannot result in a value below zero.
    pub fn step_len_ms(&amp;self) -&gt; u32 {
        let result = 1000 - (200 * ((self.speed as i32) - 1));
        if result &lt; 200 {
            200u32
        } else {
            result as u32
        }
    }

    /// Return an array representing the game state, which can be used to display the
    /// state on the microbit's LED matrix. Each `_brightness` parameter should be a
    /// value between 0 and 9.
    pub fn game_matrix(
        &amp;self,
        head_brightness: u8,
        tail_brightness: u8,
        food_brightness: u8,
    ) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        values[self.snake.head.row as usize][self.snake.head.col as usize] = head_brightness;
        for t in &amp;self.snake.tail {
            values[t.row as usize][t.col as usize] = tail_brightness
        }
        values[self.food_coords.row as usize][self.food_coords.col as usize] = food_brightness;
        values
    }

    /// Return an array representing the game score, which can be used to display the
    /// score on the microbit's LED matrix (by illuminating the equivalent number of
    /// LEDs, going left-&gt;right and top-&gt;bottom).
    pub fn score_matrix(&amp;self) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        let full_rows = (self.score as usize) / 5;
        #[allow(clippy::needless_range_loop)]
        for r in 0..full_rows {
            values[r] = [1; 5];
        }
        for c in 0..(self.score as usize) % 5 {
            values[full_rows][c] = 1;
        }
        values
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Next we will add the ability to control the snake's movements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controls"><a class="header" href="#controls">Controls</a></h1>
<p>Our protagonist will be controlled by the two buttons on the front of the micro:bit. Button A will
turn to the snake's left, and button B will turn to the snake's right.</p>
<p>We will use the <code>microbit::pac::interrupt</code> macro to handle button presses in a concurrent way. The
interrupt will be generated by the MB2's General Purpose Input/Output Tasks and Events (GPIOTE)
peripheral.</p>
<h2 id="the-controls-module"><a class="header" href="#the-controls-module">The <code>controls</code> module</a></h2>
<p>We will need to keep track of two separate pieces of global mutable state: A reference to the
<code>GPIOTE</code> peripheral, and a record of the selected direction to turn next.</p>
<p>Shared data is wrapped in a <code>RefCell</code> to permit interior mutability and locking. You can learn more
about <code>RefCell</code> by reading the <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell documentation</a> and the <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability chapter</a> of the
Rust Book].  The <code>RefCell</code> is, in turn, wrapped in a <code>cortex_m::interrupt::Mutex</code> to allow safe
access.  The Mutex provided by the <code>cortex_m</code> crate uses the concept of a <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>.  Data
in a Mutex can only be accessed from within a function or closure passed to
<code>cortex_m::interrupt::free</code> (renamed here to <code>interrupt_free</code> for clarity), which ensures that the
code in the function or closure cannot itself be interrupted.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>First, we will initialize the buttons (<code>src/controls/init.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Buttons, GPIO};

use cortex_m::interrupt::free as interrupt_free;
use microbit::{
    hal::{
        gpio::{Floating, Input, Pin},
        gpiote::{Gpiote, GpioteChannel},
    },
    pac,
};

/// Initialise the buttons and enable interrupts.
pub fn init_buttons(board_gpiote: pac::GPIOTE, board_buttons: Buttons) {
    let gpiote = Gpiote::new(board_gpiote);

    fn init_channel(channel: &amp;GpioteChannel&lt;'_&gt;, button: &amp;Pin&lt;Input&lt;Floating&gt;&gt;) {
        channel.input_pin(button).hi_to_lo().enable_interrupt();
        channel.reset_events();
    }

    let channel0 = gpiote.channel0();
    init_channel(&amp;channel0, &amp;board_buttons.button_a.degrade());

    let channel1 = gpiote.channel1();
    init_channel(&amp;channel1, &amp;board_buttons.button_b.degrade());

    interrupt_free(move |cs| {
        *GPIO.borrow(cs).borrow_mut() = Some(gpiote);

        unsafe {
            pac::NVIC::unmask(pac::Interrupt::GPIOTE);
        }
        pac::NVIC::unpend(pac::Interrupt::GPIOTE);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>GPIOTE</code> peripheral on the nRF52 has 8 "channels", each of which can be connected to a <code>GPIO</code>
pin and configured to respond to certain events, including rising edge (transition from low to high
signal) and falling edge (high to low signal). A button is a <code>GPIO</code> pin which has high signal when
not pressed and low signal otherwise. Therefore, a button press is a falling edge.</p>
<p>Note the awkward use of the function <code>init_channel()</code> in initialization to avoid copy-pasting the
button initialization code. The types that the various embedded crates for the MB2 have been hiding
from you are sometimes a bit scary. I would encourage you to explore the type structure of the HAL
and PAC crates at some point, as it is a bit odd and takes getting used to. In particular, note that
each pin on the microbit has <em>its own unique type.</em> The purpose of the <code>degrade()</code> function in
initialization is to convert these to a common type that can reasonably be used as an argument to
<code>init_channel()</code> and thence to <code>input_pin()</code>.</p>
<p>We connect <code>channel0</code> to <code>button_a</code> and <code>channel1</code> to <code>button_b</code>. In each case, we set the button up
to generate events on a falling edge (<code>hi_to_lo</code>). We store a reference to our <code>GPIOTE</code> peripheral
in the <code>GPIO</code> Mutex. We then <code>unmask</code> <code>GPIOTE</code> interrupts, allowing them to be propagated by the
hardware, and call <code>unpend</code> to clear any interrupts with pending status (which may have been
generated prior to the interrupts being unmasked).</p>
<h3 id="interrupt-handler"><a class="header" href="#interrupt-handler">Interrupt handler</a></h3>
<p>Next, we write the code that handles the interrupt. We use the <code>interrupt</code> macro re-exported from
the <code>nrf52833_hal</code> crate. We define a function with the same name as the interrupt we want to handle
(you can see them all
<a href="https://docs.rs/nrf52833-hal/latest/nrf52833_hal/pac/enum.Interrupt.html">here</a>) and annotate it
with <code>#[interrupt]</code> (<code>src/controls/interrupt.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Turn, GPIO, TURN};

use cortex_m::interrupt::free as interrupt_free;
use microbit::pac::{self, interrupt};

#[pac::interrupt]
fn GPIOTE() {
    interrupt_free(|cs| {
        if let Some(gpiote) = GPIO.borrow(cs).borrow().as_ref() {
            let a_pressed = gpiote.channel0().is_event_triggered();
            let b_pressed = gpiote.channel1().is_event_triggered();

            let turn = match (a_pressed, b_pressed) {
                (true, false) =&gt; Turn::Left,
                (false, true) =&gt; Turn::Right,
                _ =&gt; Turn::None,
            };

            gpiote.channel0().reset_events();
            gpiote.channel1().reset_events();

            *TURN.borrow(cs).borrow_mut() = turn;
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<p>When a <code>GPIOTE</code> interrupt is generated, we check each button to see whether it has been pressed. If
only button A has been pressed, we record that the snake should turn to the left. If only button B
has been pressed, we record that the snake should turn to the right. In any other case, we record
that the snake should not make any turn. (Having both buttons pressed "at the same time" is
exceedingly unlikely: button presses are noted almost instantly, and this interrupt handler runs
very fast — it would be hard to get both buttons down in time for this to happen. Similarly, it
would be hard to press a button for a short enough time for this code to miss it and report that
neither button is pressed. Still, Rust enforces that you plan for these unexpected cases: the code
will not compile unless you check all the possibilities.) The relevant turn is stored in the <code>TURN</code>
Mutex. All of this happens within an <code>interrupt_free</code> block, to ensure that we cannot be interrupted
by some other event while handling this interrupt.</p>
<p>Finally, we expose a simple function to get the next turn (<code>src/controls.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod init;
mod interrupt;

pub use init::init_buttons;

use crate::game::Turn;
use core::cell::RefCell;
use cortex_m::interrupt::{free as interrupt_free, Mutex};
use microbit::{board::Buttons, hal::gpiote::Gpiote};
pub static GPIO: Mutex&lt;RefCell&lt;Option&lt;Gpiote&gt;&gt;&gt; = Mutex::new(RefCell::new(None));
pub static TURN: Mutex&lt;RefCell&lt;Turn&gt;&gt; = Mutex::new(RefCell::new(Turn::None));

/// Get the next turn (ie, the turn corresponding to the most recently pressed button).
pub fn get_turn(reset: bool) -&gt; Turn {
    interrupt_free(|cs| {
        let turn = *TURN.borrow(cs).borrow();
        if reset {
            *TURN.borrow(cs).borrow_mut() = Turn::None
        }
        turn
    })
}
<span class="boring">}</span></code></pre></pre>
<p>This function simply returns the current value of the <code>TURN</code> Mutex. It takes a single boolean
argument, <code>reset</code>. If <code>reset</code> is <code>true</code>, the value of <code>TURN</code> is reset, i.e., set to <code>Turn::None</code>.</p>
<p>Next we will build support for a high-fidelity game display.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-non-blocking-display"><a class="header" href="#using-the-non-blocking-display">Using the non-blocking display</a></h1>
<p>We will next display the snake and food on the LEDs of the MB2 screen. So far, we have used the
blocking interface, which provides for LEDs to be either maximally bright or turned off. With this,
a basic functioning snake game would be possible. But you might find that when the snake got a bit
longer, it would be difficult to tell the snake from the food, and to tell which direction the snake
was heading. Let's figure out how to allow the LED brightness to vary: we can make the snake's body
a bit dimmer, which will help sort out the clutter.</p>
<p>The <code>microbit</code> library makes available two different interfaces to the LED matrix. There is the
blocking interface we've already seen in previous chapters. There is also a non-blocking interface
which allows you to customise the brightness of each LED. At the hardware level, each LED is either
"on" or "off", but the <code>microbit::display::nonblocking</code> module simulates ten levels of brightness
for each LED by rapidly switching the LED on and off.</p>
<p>(There is no great reason the two display modes of the <code>microbit</code> library crate have to be separate
and use separate code. A more complete design would allow either non-blocking or blocking use of a
single display API with variable brightness levels and refresh rates specified by the user. Never
assume that the stuff you have been handed is perfected, or even close. Always think about what you
might do differently. For now, though, we'll work with what we have, which is adequate for our
immediate purpose.)</p>
<p>The code to interact with the non-blocking interface (<code>src/display.rs</code>) is pretty simple and will
follow a similar structure to the code we used to interact with the buttons. This time we'll start
at the top level.</p>
<h2 id="display-module"><a class="header" href="#display-module">Display module</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod interrupt;
pub mod show;

pub use show::{clear_display, display_image};

use core::cell::RefCell;
use cortex_m::interrupt::{free as interrupt_free, Mutex};
use microbit::display::nonblocking::Display;
use microbit::gpio::DisplayPins;
use microbit::pac;
use microbit::pac::TIMER1;

static DISPLAY: Mutex&lt;RefCell&lt;Option&lt;Display&lt;TIMER1&gt;&gt;&gt;&gt; = Mutex::new(RefCell::new(None));

pub fn init_display(board_timer: TIMER1, board_display: DisplayPins) {
    let display = Display::new(board_timer, board_display);

    interrupt_free(move |cs| {
        *DISPLAY.borrow(cs).borrow_mut() = Some(display);
    });
    unsafe { pac::NVIC::unmask(pac::Interrupt::TIMER1) }
}
<span class="boring">}</span></code></pre></pre>
<p>First, we initialize a <code>microbit::display::nonblocking::Display</code> struct representing the LED
display, passing it the board's <code>TIMER1</code> and <code>DisplayPins</code> peripherals. Then we store the display in
a Mutex. Finally, we unmask the <code>TIMER1</code> interrupt.</p>
<h2 id="display-api"><a class="header" href="#display-api">Display API</a></h2>
<p>We then define a couple of convenience functions which allow us to easily set (or unset) the image
to be displayed (<code>src/display/show.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::DISPLAY;

use cortex_m::interrupt::free as interrupt_free;

use tiny_led_matrix::Render;

/// Display an image.
pub fn display_image(image: &amp;impl Render) {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.show(image);
        }
    })
}

/// Clear the display (turn off all LEDs).
pub fn clear_display() {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.clear();
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_image</code> takes an image and tells the display to show it. Like the <code>Display::show</code> method
that it calls, this function takes a struct that implements the <code>tiny_led_matrix::Render</code>
trait. That trait ensures that the struct contains the data and methods necessary for the <code>Display</code>
to render it on the LED matrix. The two implementations of <code>Render</code> provided by the
<code>microbit::display::nonblocking</code> module are <code>BitImage</code> and <code>GreyscaleImage</code>. In a <code>BitImage</code>, each
"pixel" (or LED) is either illuminated or not (like when we used the blocking interface), whereas in
a <code>GreyscaleImage</code> each "pixel" can have a different brightness.</p>
<p><code>clear_display</code> does exactly as the name suggests.</p>
<h2 id="display-interrupt-handling"><a class="header" href="#display-interrupt-handling">Display interrupt handling</a></h2>
<p>Finally, we use the <code>interrupt</code> macro to define a handler for the <code>TIMER1</code> interrupt. This interrupt
fires many times a second, and this is what allows the <code>Display</code> to rapidly cycle the different LEDs
on and off to give the illusion of varying brightness levels. All our handler code does is call the
<code>Display::handle_display_event</code> method, which handles this (<code>src/display/interrupt.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::DISPLAY;

use cortex_m::interrupt::free as interrupt_free;
use microbit::pac::{self, interrupt};

#[pac::interrupt]
fn TIMER1() {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.handle_display_event();
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>Now we can understand how our <code>main</code> function will do display: we will call <code>init_display</code> and use
the new functions we have defined to interact with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snake-game-final-assembly"><a class="header" href="#snake-game-final-assembly">Snake game: final assembly</a></h1>
<p>The code in our <code>src/main.rs</code> file brings all the previously-discussed machinery together to make
our final game.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

mod controls;
mod display;
pub mod game;

use controls::{get_turn, init_buttons};
use display::{clear_display, display_image, init_display};
use game::{Game, GameStatus};

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use microbit::{
    display::nonblocking::{BitImage, GreyscaleImage},
    hal::{Rng, Timer},
    Board,
};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0).into_periodic();
    let mut rng = Rng::new(board.RNG);
    let mut game = Game::new(&amp;mut rng);

    init_buttons(board.GPIOTE, board.buttons);
    init_display(board.TIMER1, board.display_pins);

    loop {
        loop {
            // Game loop
            let image = GreyscaleImage::new(&amp;game.game_matrix(6, 3, 9));
            display_image(&amp;image);
            timer.delay_ms(game.step_len_ms());
            match game.status {
                GameStatus::Ongoing =&gt; game.step(get_turn(true)),
                _ =&gt; {
                    for _ in 0..3 {
                        clear_display();
                        timer.delay_ms(200u32);
                        display_image(&amp;image);
                        timer.delay_ms(200u32);
                    }
                    clear_display();
                    display_image(&amp;BitImage::new(&amp;game.score_matrix()));
                    timer.delay_ms(2000u32);
                    break;
                }
            }
        }
        game.reset();
    }
}</code></pre></pre>
<p>After initializing the board and its timer and RNG peripherals, we initialize a <code>Game</code> struct and a
<code>Display</code> from the <code>microbit::display::blocking</code> module.</p>
<p>In our "game loop" (which runs inside of the "main loop" we place in our <code>main</code> function), we
repeatedly perform the following steps:</p>
<ol>
<li>
<p>Get a 5×5 array of bytes representing the grid. The <code>Game::get_matrix</code> method takes three integer
arguments (which should be between 0 and 9, inclusive) which will, eventually, represent how
brightly the head, tail and food should be displayed.</p>
</li>
<li>
<p>Display the matrix, for an amount of time determined by the <code>Game::step_len_ms</code> method. As
currently implemented, this method basically provides for 1 second between steps, reducing by
200ms every time the player scores 5 points (eating 1 piece of food = 1 point), subject to a
floor of 200ms.</p>
</li>
<li>
<p>Check the game status. If it is <code>Ongoing</code> (which is its initial value), run a step of the game
and update the game state (including its <code>status</code> property). Otherwise, the game is over, so
flash the current image three times, then show the player's score (represented as a number of
illuminated LEDs corresponding to the score), and exit the game loop.</p>
</li>
</ol>
<p>Our main loop just runs the game loop repeatedly, resetting the game's state after each iteration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-left-for-you-to-explore"><a class="header" href="#whats-left-for-you-to-explore">What's left for you to explore</a></h1>
<p>We have barely scratched the surface! There's lots of stuff left for you to
explore.</p>
<blockquote>
<p><strong>NOTE:</strong> If you're reading this, and you'd like to help add examples or
exercises to the Discovery book for any of the items below, or any other
relevant embedded topics, we'd love to have your help!</p>
<p>Please <a href="https://github.com/rust-embedded/discovery-mb2/issues/new">open an issue</a> if you would like to help, but need assistance or
mentoring for how to contribute this to the book, or open a Pull Request
adding the information!</p>
</blockquote>
<h2 id="more-of-the-mb2"><a class="header" href="#more-of-the-mb2">More of the MB2</a></h2>
<p>We touched most of the hardware on the MB2 in the course of this book. That said, there's still a
few MB2 topics left to explore.</p>
<h2 id="direct-memory-access-dma"><a class="header" href="#direct-memory-access-dma">Direct Memory Access (DMA).</a></h2>
<p>Some peripherals have DMA, a kind of <em>asynchronous</em> <code>memcpy</code> that allows the peripheral to move data
into or out of memory without the CPU being involved.</p>
<p>If you are working with a micro:bit v2 you have actually already used DMA: the HAL does this for you
with the UARTE and TWIM peripherals. A DMA peripheral can be used to perform bulk transfers of data:
either from RAM to RAM, from a peripheral like a UARTE, to RAM, or from RAM to a peripheral. You can
schedule a DMA transfer — for example "read 256 bytes from UARTE into this buffer" — and leave it
running in the background. You can check some register later to see if the transfer has completed,
or you can ask to receive an interrupt when the transfer completes. Thus, you can schedule the DMA
transfer and do other work while the transfer is ongoing.</p>
<p>The details of low-level DMA can be a bit tricky. We hope to add a chapter covering this topic in
the near future.</p>
<p>There are some abstraction for working with PWM in the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/pwm/index.html"><code>pwm</code> module</a> and you will
find implementations of these traits in <code>nrf52833-hal</code>.</p>
<h2 id="digital-inputs-and-outputs"><a class="header" href="#digital-inputs-and-outputs">Digital inputs and outputs</a></h2>
<p>We have used the microcontroller pins as digital outputs, to drive LEDs. When building our snake
game, we also caught a glimpse of how these pins can be configured as digital inputs. As digital
inputs, these pins can read the binary state of switches (on/off) or buttons (pressed/not pressed).</p>
<p>Digital inputs and outputs are abstracted within the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/digital/index.html"><code>digital</code> module</a> and
[<code>nrf52833-hal</code>] does have an implementation for them.</p>
<p>(<em>spoilers</em> reading the binary state of switches / buttons is not as straightforward as it sounds
;-) )</p>
<h2 id="analog-to-digital-converters-adc"><a class="header" href="#analog-to-digital-converters-adc">Analog-to-Digital Converters (ADC)</a></h2>
<p>There are a lot of digital sensors out there. You can use a protocol like I2C and SPI to read
them. But analog sensors also exist! These sensors just output a reading to the CPU of the voltage
they are sensing at an ADC input pin.</p>
<p>The ADC peripheral can thus be used to measure an "analog" voltage level — for example, <code>1.25</code> Volts
— as a "digital" number — for example, <code>24824</code> — that the processor can use in its calculations.</p>
<p>There were generic ADC traits in <code>embedded-hal</code>, but they were removed for <code>embedded-hal</code> 1.0: see
<a href="https://github.com/rust-embedded/embedded-hal/issues/377">issue #377</a>. The <code>nrf52833-hal</code> crate provides a nice interface to the specific ADC built into the
nRF52833.</p>
<h2 id="digital-to-analog-converters-dac"><a class="header" href="#digital-to-analog-converters-dac">Digital-to-Analog Converters (DAC)</a></h2>
<p>As you might expect a DAC is exactly the opposite of ADC. You can write some digital number into a
register to produce a specific voltage on some analog output pin. When this analog output pin is
connected to some appropriate electronics and the register is written to quickly with the right
values you can do things like produce sounds or music.</p>
<p>Neither the nRF52833 nor the MB2 board has a dedicated DAC. One typically gets a kind of DAC effect
by outputting PWM and using a bit of electronics on the output (RC filter) to "smooth" out the PWM
waveform.</p>
<h2 id="real-time-clock"><a class="header" href="#real-time-clock">Real Time Clock</a></h2>
<p>A Real-Time Clock peripheral keeps track of time under its own power, usually in "human format":
seconds, minutes, hours, days, months and years.  Some Real-Time Clocks even handle leap years and
Daylight Saving Time automatically.</p>
<p>Neither the nRF52833 nor the MB2 board contains a Real-Time Clock. The nRF52833 does contain
"Real-Time Counter" (RTC), a low-frequency ticking clock that is supported by <code>nrf52833-hal</code>.  This
counter can be dedicated to serve as a synthesized real-time clock. The key requirement, of course,
is to keep the RTC peripheral powered even when the MB2 is not in use. While the MB2 does not have
an on-board battery, the RTC should be able to run for a long time (possibly years) with a battery
plugged into the battery port on the MB2 (for example, the battery pack provided with the micro::bit
Go kit).</p>
<h2 id="other-communication-protocols"><a class="header" href="#other-communication-protocols">Other communication protocols</a></h2>
<ul>
<li>SPI: The "Serial Peripheral Interface" is a high-speed communications interface similar in some
ways to I2C. SPI is abstracted within the <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/spi/index.html"><code>embedded-hal</code> <code>spi</code> module</a> and implemented by
[<code>nrf52-hal</code>].</li>
<li>I2S: The "Inter-IC Sound" protocol is a variant of I2C customized for audio transmission.
I2S is currently not abstracted within <code>embedded-hal</code>, but is implemented by [<code>nrf52-hal</code>].</li>
<li>Ethernet: there does exist a small TCP/IP stack named <a href="https://github.com/smoltcp-rs/smoltcp"><code>smoltcp</code></a> which is implemented for some
chips. The MB2 does not have an Ethernet peripheral</li>
<li>USB: there is some experimental work on this, for example with the <a href="https://github.com/mvirkkunen/usb-device"><code>usb-device</code></a> crate. For
the MB2, the USB port is managed by the interface MCU rather than the host MCU, making
it difficult to do custom USB things.</li>
<li>Bluetooth: the <code>nrf-softdevice</code> wrapper provided by the <a href="https://embassy.dev">Embassy</a> MB2 runtime is probably the
easiest entry into MB2 Bluetooth. Embassy also sports the Rust-native <a href="https://crates.io/crates/trouble-host"><code>TrouBLE</code></a> BLE host crate.</li>
<li>CAN, SMBUS, IrDA, etc: All kinds of specialty interfaces exist in the world; Rust sometimes has
support for them. Please investigate the current situation for the interface you need</li>
</ul>
<p>Different applications use different communication protocols. User facing applications usually have
a USB connector because USB is a ubiquitous protocol in PCs and smartphones. Whereas inside cars
you'll find plenty of CAN buses. Some digital sensors use SPI, I2C or SMBUS.</p>
<p>If you happen to be interested in developing abstractions in the <code>embedded-hal</code> or implementations
of peripherals in general, don't be shy to open an issue in the HAL repositories. Alternatively you
could also join the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a> and get into contact with most of the people who
built the stuff from above.</p>
<h2 id="general-embedded-relevant-topics"><a class="header" href="#general-embedded-relevant-topics">General Embedded-Relevant Topics</a></h2>
<p>These topics cover items that are not specific to our device, or the hardware on it. Instead, they
discuss useful techniques that could be used on embedded systems.</p>
<p>Most of the hardware we will discuss here is not available on the MB2 — but much of it could easily
be added by connecting a cheap piece of hardware to the MB2 edge-card connector, either driving it
directly or using something like SPI or I2C to control it.</p>
<h3 id="multitasking"><a class="header" href="#multitasking">Multitasking</a></h3>
<p>Most of our programs executed a single task. How could we achieve multitasking in a system with no
OS, and thus no threads? There are two main approaches to multitasking: preemptive multitasking and
cooperative multitasking.</p>
<p>In preemptive multitasking a task that's currently being executed can, at any point in time, be
<em>preempted</em> (interrupted) by another task. On preemption, the first task will be suspended and the
processor will instead execute the second task. At some point the first task will be resumed.
Microcontrollers provide hardware support for preemption in the form of <em>interrupts</em>. We were
introduced to interrupts when we built our snake game in <a href="16-snake-game/index.html">chapter 16</a>.</p>
<p>In cooperative multitasking a task that's being executed will run until it reaches a <em>suspension
point</em>. When the processor reaches that suspension point it will stop executing the current task and
instead go and execute a different task. At some point the first task will be resumed. The main
difference between these two approaches to multitasking is that in cooperative multitasking <em>yields</em>
execution control at <em>known</em> suspension points instead of being forcefully preempted at any point of
its execution.</p>
<h3 id="gyroscopes"><a class="header" href="#gyroscopes">Gyroscopes</a></h3>
<p>As part of our Punch-o-meter exercise, we used the Accelerometer to measure changes in acceleration
in three dimensions. But there are other motion sensors such as gyroscopes, which allows us to
measure changes in "spin" in three dimensions.</p>
<p>This can be very useful when trying to build certain systems, such as a robot that wants to avoid
tipping over. Additionally, the data from a sensor like a gyroscope can also be combined with data
from accelerometer using a technique called Sensor Fusion (see below for more information).</p>
<h3 id="servo-and-stepper-motors"><a class="header" href="#servo-and-stepper-motors">Servo and Stepper Motors</a></h3>
<p>While some motors are used primarily just to spin in one direction or the other, for example driving
a remote control car forwards or backwards, it is sometimes useful to measure more precisely how a
motor rotates.</p>
<p>A microcontroller can be used to drive Servo or Stepper motors, which allow for more precise control
of how many turns are being made by the motor, or can even position the motor in one specific place,
for example if we wanted to move the arms of a clock to a particular direction.</p>
<h3 id="sensor-fusion"><a class="header" href="#sensor-fusion">Sensor fusion</a></h3>
<p>The micro:bit contains two motion sensors: an accelerometer and a magnetometer.  On their own these
measure (proper) acceleration and (the Earth's) magnetic field.  But these magnitudes can be "fused"
into something more useful: a "robust" measurement of the orientation of the board, with less
measurement error than that of any single sensor.</p>
<p>This idea of deriving more reliable data from different sources is known as sensor fusion.</p>
<hr />
<p>So where to next?</p>
<p>First and foremost, join us on the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a>. Lots of people who contribute or
work on embedded software hang out there, including, for example, the people who wrote the
<code>microbit</code> BSP, the <code>nrf52-hal</code> crate, the <code>embedded-hal</code> crates, etc. We are happy to help you get
started or move on with embedded programming in Rust!</p>
<p>There are many other options:</p>
<ul>
<li>You could check out the examples in the <a href="https://github.com/nrf-rs/microbit/"><code>microbit-v2</code></a> board support crate. All those examples
work for the micro:bit board you have.</li>
</ul>
<ul>
<li>If you are looking for a general overview of what is available in Rust Embedded right now check
out the <a href="https://github.com/rust-embedded/awesome-embedded-rust/">Awesome Rust Embedded</a> list.</li>
</ul>
<ul>
<li>You could check out <a href="https://embassy.dev">Embassy</a>. This is a modern efficient cooperative multitasking framework that
supports concurrent execution using Rust <code>async/await</code>.</li>
</ul>
<ul>
<li>You could check out Real-Time Interrupt-driven Concurrency <a href="https://rtic.rs">RTIC</a>. RTIC is a very efficient
preemptive multitasking framework that supports task prioritization and deadlock-free execution.</li>
</ul>
<ul>
<li>You could check out more abstractions of the <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> project and maybe even try and write
your own platform agnostic driver based on it.</li>
</ul>
<ul>
<li>You could try running Rust on a different development board. Popular boards such as the ESP-32,
Raspberry Pi, or Arduino have their own active Rust developer communities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-download-epub-version-of-the-book"><a class="header" href="#-download-epub-version-of-the-book">📥 download ePUB version of the book</a></h1>
<p>You can download the EPUB version of this book here:  <a href="/discovery-mb2/Rust%20Embedded%20MB2%20Discovery%20Book.epub">Download</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-troubleshooting"><a class="header" href="#general-troubleshooting">General troubleshooting</a></h1>
<h2 id="cargo-embed-problems"><a class="header" href="#cargo-embed-problems"><code>cargo-embed</code> problems</a></h2>
<p>Most <code>cargo-embed</code> problems are related to not having installed the <code>udev</code> rules properly on
Linux, so make sure you got that right.</p>
<p>If you are stuck, you can open an issue in the <a href="https://github.com/rust-embedded/discovery-mb2/issues"><code>discovery</code> issue tracker</a> or visit the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust
Embedded matrix channel</a> or the <a href="https://matrix.to/#/#probe-rs:matrix.org">probe-rs matrix channel</a> and ask for help there.</p>
<h2 id="cargo-problems"><a class="header" href="#cargo-problems">Cargo problems</a></h2>
<h3 id="cant-find-crate-for-core"><a class="header" href="#cant-find-crate-for-core">"can't find crate for <code>core</code>"</a></h3>
<p><em>Symptoms:</em></p>
<pre><code>   Compiling volatile-register v0.1.2
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
Build failed, waiting for other jobs to finish...
error: Could not compile `r0`.

To learn more, run the command again with --verbose.
</code></pre>
<p><em>Cause:</em></p>
<p>You forgot to install the proper target for your microcontroller <code>thumbv7em-none-eabihf</code>.</p>
<p><em>Fix:</em></p>
<p>Install the proper target.</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-gdb"><a class="header" href="#how-to-use-gdb">How to use GDB</a></h1>
<p>Below are some useful GDB commands that can help us debug our programs. This assumes you have
<a href="appendix/2-how-to-use-gdb/../../05-meet-your-software/flash-it.html">flashed a program</a> onto your microcontroller and
attached GDB to a <code>cargo-embed</code> session.</p>
<h2 id="general-debugging"><a class="header" href="#general-debugging">General Debugging</a></h2>
<blockquote>
<p><strong>NOTE:</strong> Many of the commands you see below can be executed using a short form. For example,
<code>continue</code> can simply be used as <code>c</code>, or <code>break $location</code> can be used as <code>b $location</code>. Once you
have experience with the commands below, try to see how short you can get the commands to go
before GDB doesn't recognize them!</p>
</blockquote>
<h3 id="dealing-with-breakpoints"><a class="header" href="#dealing-with-breakpoints">Dealing with Breakpoints</a></h3>
<ul>
<li><code>break $location</code>: Set a breakpoint at a place in your code. The value of <code>$location</code> can include:
<ul>
<li><code>break *main</code> - Break on the exact address of the function <code>main</code></li>
<li><code>break *0x080012f2</code> - Break on the exact memory location <code>0x080012f2</code></li>
<li><code>break 123</code> - Break on line 123 of the currently displayed file</li>
<li><code>break main.rs:123</code> - Break on line 123 of the file <code>main.rs</code></li>
</ul>
</li>
<li><code>info break</code>: Display current breakpoints</li>
<li><code>delete</code>: Delete all breakpoints
<ul>
<li><code>delete $n</code>: Delete breakpoint <code>$n</code> (<code>n</code> being a number. For example: <code>delete $2</code>)</li>
</ul>
</li>
<li><code>clear</code>: Delete breakpoint at next instruction
<ul>
<li><code>clear main.rs:$function</code>: Delete breakpoint at entry of <code>$function</code> in <code>main.rs</code></li>
<li><code>clear main.rs:123</code>: Delete breakpoint on line 123 of <code>main.rs</code></li>
</ul>
</li>
<li><code>enable</code>: Enable all set breakpoints
<ul>
<li><code>enable $n</code>: Enable breakpoint <code>$n</code></li>
</ul>
</li>
<li><code>disable</code>: Disable all set breakpoints
<ul>
<li><code>disable $n</code>: Disable breakpoint <code>$n</code></li>
</ul>
</li>
</ul>
<h3 id="controlling-execution"><a class="header" href="#controlling-execution">Controlling Execution</a></h3>
<ul>
<li><code>continue</code>: Begin or continue execution of your program</li>
<li><code>next</code>: Execute the next line of your program
<ul>
<li><code>next $n</code>: Repeat <code>next</code> <code>$n</code> number times</li>
</ul>
</li>
<li><code>nexti</code>: Same as <code>next</code> but with machine instructions instead</li>
<li><code>step</code>: Execute the next line, if the next line includes a call to another function, step into that code
<ul>
<li><code>step $n</code>: Repeat <code>step</code> <code>$n</code> number times</li>
</ul>
</li>
<li><code>stepi</code>: Same as <code>step</code> but with machine instructions instead</li>
<li><code>jump $location</code>: Resume execution at specified location:
<ul>
<li><code>jump 123</code>: Resume execution at line 123</li>
<li><code>jump 0x080012f2</code>: Resume execution at address 0x080012f2</li>
</ul>
</li>
</ul>
<h3 id="printing-information"><a class="header" href="#printing-information">Printing Information</a></h3>
<ul>
<li>
<p><code>print /$f $data</code> - Print the value contained by the variable <code>$data</code>. Optionally format the
output with <code>$f</code>, which can include:</p>
<pre><code class="language-txt">x: hexadecimal
d: signed decimal
u: unsigned decimal
o: octal
t: binary
a: address
c: character
f: floating point
</code></pre>
<ul>
<li><code>print /t 0xA</code>: Prints the hexadecimal value <code>0xA</code> as binary (0b1010)</li>
</ul>
</li>
<li>
<p><code>x /$n$u$f $address</code>: Examine memory at <code>$address</code>. Optionally, <code>$n</code> define the number of units to
display, <code>$u</code> unit size (bytes, halfwords, words, etc.), <code>$f</code> any <code>print</code> format defined above</p>
<ul>
<li><code>x /5i 0x080012c4</code>: Print 5 machine instructions staring at address <code>0x080012c4</code></li>
<li><code>x/4xb $pc</code>: Print 4 bytes of memory starting where <code>$pc</code> currently is pointing</li>
</ul>
</li>
<li>
<p><code>disassemble $location</code></p>
<ul>
<li><code>disassemble /r main</code>: Disassemble the function <code>main</code>, using <code>/r</code> to show the bytes that make
up each instruction</li>
</ul>
</li>
</ul>
<h3 id="looking-at-the-symbol-table"><a class="header" href="#looking-at-the-symbol-table">Looking at the Symbol Table</a></h3>
<ul>
<li><code>info functions $regex</code>: Print the names and data types of functions matched by <code>$regex</code>, omit
<code>$regex</code> to print all functions
<ul>
<li><code>info functions main</code>: Print names and types of defined functions that contain the word <code>main</code></li>
</ul>
</li>
<li><code>info address $symbol</code>: Print where <code>$symbol</code> is stored in memory
<ul>
<li><code>info address GPIOC</code>: Print the memory address of the variable <code>GPIOC</code></li>
</ul>
</li>
<li><code>info variables $regex</code>: Print names and types of global variables matched by <code>$regex</code>, omit
<code>$regex</code> to print all global variables</li>
<li><code>ptype $data</code>: Print more detailed information about <code>$data</code>
<ul>
<li><code>ptype cp</code>: Print detailed type information about the variable <code>cp</code></li>
</ul>
</li>
</ul>
<h3 id="poking-around-the-program-stack"><a class="header" href="#poking-around-the-program-stack">Poking around the Program Stack</a></h3>
<ul>
<li><code>backtrace $n</code>: Print trace of <code>$n</code> frames, or omit <code>$n</code> to print all frames
<ul>
<li><code>backtrace 2</code>: Print trace of first 2 frames</li>
</ul>
</li>
<li><code>frame $n</code>: Select frame with number or address <code>$n</code>, omit <code>$n</code> to display current frame</li>
<li><code>up $n</code>: Select frame <code>$n</code> frames up</li>
<li><code>down $n</code>: Select frame <code>$n</code> frames down</li>
<li><code>info frame $address</code>: Describe frame at <code>$address</code>, omit <code>$address</code> for currently selected frame</li>
<li><code>info args</code>: Print arguments of selected frame</li>
<li><code>info registers $r</code>: Print the value of register <code>$r</code> in selected frame, omit <code>$r</code> for all
registers
<ul>
<li><code>info registers $sp</code>: Print the value of the stack pointer register <code>$sp</code> in the current frame</li>
</ul>
</li>
</ul>
<h3 id="controlling-cargo-embed-remotely"><a class="header" href="#controlling-cargo-embed-remotely">Controlling <code>cargo-embed</code> Remotely</a></h3>
<ul>
<li><code>monitor reset</code>: Reset the CPU, starting execution over again</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magnetometer-calibration"><a class="header" href="#magnetometer-calibration">Magnetometer Calibration</a></h1>
<p>One very important thing to do before using a sensor and trying to develop an application using it
is verifying that it's output is actually correct.  If this does not happen to be the case we need
to calibrate the sensor. Alternatively the sensor could be broken: health-checking sensors before
and during use is a really good idea when possible.</p>
<p>In my case, on two different MB2s the LSM303AGR's magnetometer without calibration is quite a bit
off.  (I also have one where the z-axis appears to be broken; the manufacturer has some extra
hardware and a process to help detect this, but we won't deal with that complexity here.)</p>
<p>There is a manufacturer-specified procedure for calibrating the magnetometer.  The calibration
involves quite a bit of math (matrices) so we won't cover it in detail here: this <a href="https://www.st.com/resource/en/design_tip/dt0103-compensating-for-magnetometer-installation-error-and-hardiron-effects-using-accelerometerassisted-2d-calibration-stmicroelectronics.pdf">Design Note</a>
describes the procedure if you are interested in the details.</p>
<p>Luckily for us, the CODAL group that built the original C++ software for the micro:bit already
implemented the manufacturer calibration mechanism (or something similar) in C++ over <a href="https://github.com/lancaster-university/codal-microbit-v2/blob/006abf5566774fbcf674c0c7df27e8a9d20013de/source/MicroBitCompassCalibrator.cpp">here</a>.</p>
<p>You can find a translation of this C++ calibration to Rust in <code>src/lib.rs</code>. Note that this is a
translation from Matlab to C++ to Rust, and that it makes some interesting choices.  In particular,
when reading calibrated values <em>the axes are flipped</em> so that viewed from the top with the USB
connector forward the X, Y and Z axes of the calibrated value are in "standard" (right, forward, up)
orientation.</p>
<p>The usage of this calibrator is demonstrated in <code>src/main.rs</code> here.</p>
<p>The way the user does the calibration is shown in this video from the C++ version. (Ignore the
initial printing — the calibration starts about halfway through.)</p>
<p align="center">
<video src="https://video.microbit.org/support/compass+calibration.mp4" loop="true" autoplay="true" />
</p>
<p>You have to tilt the micro:bit until all the LEDs on the LED matrix light up. The blinking cursor
shows the current target LED.</p>
<p>Note that the calibration matrix is printed by the demo program. This matrix can be hard-coded into
a program such as the [chapter 12] compass program (or stored in flash somewhere somehow) to avoid
the need to recalibrate every time the user runs the program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="licenses-and-attribution"><a class="header" href="#licenses-and-attribution">Licenses and Attribution</a></h1>
<h2 id="licenses"><a class="header" href="#licenses">Licenses</a></h2>
<p>The documentation is licensed under</p>
<ul>
<li>Creative Commons Attribution 4.0 License (<a href="appendix/4-licenses-and-attribution/LICENSE-CC-BY">LICENSE-CC-BY</a>
or https://creativecommons.org/licenses/by/4.0/legalcode)</li>
</ul>
<p>And the source code is licensed under either of</p>
<ul>
<li>
<p>Apache License, Version 2.0 (<a href="appendix/4-licenses-and-attribution/LICENSE-APACHE">LICENSE-APACHE</a> or
http://www.apache.org/licenses/LICENSE-2.0)</p>
</li>
<li>
<p>MIT License (<a href="appendix/4-licenses-and-attribution/LICENSE-MIT">LICENSE-MIT</a> or
https://opensource.org/licenses/MIT)</p>
</li>
</ul>
<p>at your option.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>The diagrams in the I2C chapter are by Tim Mathias. They are
taken from Wikimedia Commons and used under the CC-BY-4.0
license.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="epub-link.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
